#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AR ç³»ç»Ÿæ™ºèƒ½å¯åŠ¨å™¨ - Python æ ¸å¿ƒé€»è¾‘
ç‰ˆæœ¬: 1.0
ä½œè€…: AI å…¨æ ˆæŠ€æœ¯å‘˜
æœ€åæ›´æ–°: 2026å¹´2æœˆ4æ—¥

åŠŸèƒ½:
- è‡ªåŠ¨ç¯å¢ƒæ£€æµ‹ (å®¹å™¨ vs æœ¬åœ°)
- è™šæ‹Ÿç¯å¢ƒæ™ºèƒ½ç®¡ç†
- ä¾èµ–è‡ªåŠ¨æ£€æŸ¥å’Œå®‰è£…
- è·¯å¾„è‡ªåŠ¨é…ç½®
"""

import os
import sys
import json
import subprocess
import platform
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# å¯¼å…¥è·¯å¾„ç®¡ç†å™¨ - Generated by Copilot
try:
    from path_manager import get_path_manager
except ImportError:
    sys.path.insert(0, str(Path(__file__).parent))
    from path_manager import get_path_manager

class ARSystemLauncher:
    """AR ç³»ç»Ÿæ™ºèƒ½å¯åŠ¨å™¨ - ä½¿ç”¨ç»Ÿä¸€è·¯å¾„ç®¡ç†å™¨"""

    def __init__(self):
        # ä½¿ç”¨ç»Ÿä¸€çš„è·¯å¾„ç®¡ç†å™¨
        self.path_mgr = get_path_manager()
        self.project_root = self.path_mgr.project_root
        self.is_container = self._detect_container()
        self.venv_path = self.project_root / ".venv"
        self.requirements_file = self.project_root / "requirements.txt"
        self.monitor_port = 5000

        # é¢œè‰²å®šä¹‰ (ç”¨äºè¾“å‡º)
        self.colors = {
            'RED': '\033[0;31m',
            'GREEN': '\033[0;32m',
            'YELLOW': '\033[1;33m',
            'BLUE': '\033[0;34m',
            'PURPLE': '\033[0;35m',
            'CYAN': '\033[0;36m',
            'NC': '\033[0m'
        }

    def _detect_container(self) -> bool:
        """æ£€æµ‹æ˜¯å¦åœ¨å®¹å™¨ä¸­è¿è¡Œ"""
        # æ£€æŸ¥ç¯å¢ƒå˜é‡
        if os.getenv('AR_CONTAINER') == 'true':
            return True

        # æ£€æŸ¥Dockerç¯å¢ƒ
        if Path('/.dockerenv').exists():
            return True

        # æ£€æŸ¥å®¹å™¨ç‰¹å®šçš„ç¯å¢ƒå˜é‡
        container_env_vars = ['DOCKER_CONTAINER', 'KUBERNETES_SERVICE_HOST']
        if any(os.getenv(var) for var in container_env_vars):
            return True

        # æ£€æŸ¥cgroup
        try:
            with open('/proc/1/cgroup', 'r') as f:
                if 'docker' in f.read().lower():
                    return True
        except:
            pass

        return False

    def log(self, message: str, color: str = 'NC') -> None:
        """è¾“å‡ºå¸¦é¢œè‰²çš„æ—¥å¿—"""
        color_code = self.colors.get(color, self.colors['NC'])
        print(f"{color_code}{message}{self.colors['NC']}")

    def run_command(self, cmd: List[str], cwd: Optional[Path] = None,
                   capture_output: bool = False) -> Tuple[int, str, str]:
        """è¿è¡Œå‘½ä»¤å¹¶è¿”å›ç»“æœ"""
        try:
            result = subprocess.run(
                cmd,
                cwd=cwd or self.project_root,
                capture_output=capture_output,
                text=True,
                timeout=300  # 5åˆ†é’Ÿè¶…æ—¶
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            return -1, "", "å‘½ä»¤æ‰§è¡Œè¶…æ—¶"
        except Exception as e:
            return -1, "", str(e)

    def setup_environment_variables(self) -> None:
        """é…ç½®ç¯å¢ƒå˜é‡ - ä½¿ç”¨PathManagerçš„è·¯å¾„"""
        self.log("ğŸ”§ é…ç½®ç¯å¢ƒå˜é‡...", "BLUE")

        # é¡¹ç›®è·¯å¾„
        os.environ['AR_PROJECT_PATH'] = str(self.project_root)
        os.environ['AR_PROJECT_ROOT'] = str(self.project_root)  # æ–°å¢ï¼Œä¾¿äºPathManagerä½¿ç”¨
        os.environ['PYTHONPATH'] = f"{self.project_root}:{os.environ.get('PYTHONPATH', '')}"

        # æ—¥å¿—é…ç½® - ä½¿ç”¨PathManagerçš„æ—¥å¿—ç›®å½•
        os.environ['AR_LOG_LEVEL'] = 'INFO'
        os.environ['AR_LOG_DIR'] = str(self.path_mgr.logs_dir)

        # æœåŠ¡é…ç½®
        os.environ['AR_MONITOR_PORT'] = str(self.monitor_port)
        os.environ['AR_GUI_ENABLED'] = 'true'

        self.log("âœ… ç¯å¢ƒå˜é‡å·²é…ç½®", "GREEN")
        self.log(f"  é¡¹ç›®è·¯å¾„: {self.project_root}", "CYAN")
        self.log(f"  æ—¥å¿—ç›®å½•: {self.path_mgr.logs_dir}", "CYAN")
        self.log(f"  ç›‘æ§ç«¯å£: {self.monitor_port}", "CYAN")

    def setup_virtual_environment(self) -> bool:
        """è®¾ç½®Pythonè™šæ‹Ÿç¯å¢ƒ"""
        self.log("ğŸ”§ è®¾ç½®Pythonè™šæ‹Ÿç¯å¢ƒ...", "BLUE")

        if not self.venv_path.exists():
            self.log("ğŸ“¦ åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ...", "YELLOW")
            returncode, stdout, stderr = self.run_command([
                sys.executable, '-m', 'venv', str(self.venv_path)
            ])

            if returncode != 0:
                self.log(f"âŒ è™šæ‹Ÿç¯å¢ƒåˆ›å»ºå¤±è´¥: {stderr}", "RED")
                return False

            self.log("âœ… è™šæ‹Ÿç¯å¢ƒåˆ›å»ºæˆåŠŸ", "GREEN")
        else:
            self.log("âœ… è™šæ‹Ÿç¯å¢ƒå·²å­˜åœ¨", "GREEN")

        # æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
        self.log("ğŸ”„ æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ...", "BLUE")

        activate_script = self.venv_path / "bin" / "activate"
        if not activate_script.exists():
            self.log(f"âŒ è™šæ‹Ÿç¯å¢ƒæ¿€æ´»è„šæœ¬ä¸å­˜åœ¨: {activate_script}", "RED")
            return False

        # åœ¨å½“å‰è¿›ç¨‹ä¸­æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
        venv_python = self.venv_path / "bin" / "python"
        venv_pip = self.venv_path / "bin" / "pip"

        if not venv_python.exists():
            self.log(f"âŒ è™šæ‹Ÿç¯å¢ƒPythonå¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: {venv_python}", "RED")
            return False

        # æ›´æ–°PATH
        venv_bin = str(self.venv_path / "bin")
        os.environ['PATH'] = f"{venv_bin}:{os.environ['PATH']}"
        os.environ['VIRTUAL_ENV'] = str(self.venv_path)

        self.log(f"âœ… è™šæ‹Ÿç¯å¢ƒ: {self.venv_path}", "GREEN")

        # å‡çº§pip
        self.log("â¬†ï¸  å‡çº§pip...", "BLUE")
        returncode, stdout, stderr = self.run_command([str(venv_pip), 'install', '--upgrade', 'pip'])
        if returncode != 0:
            self.log(f"âš ï¸  pipå‡çº§å¤±è´¥ï¼Œä½†ç»§ç»­æ‰§è¡Œ: {stderr}", "YELLOW")

        return True

    def parse_requirements(self) -> Tuple[List[str], Optional[str]]:
        """è§£ærequirements.txtæ–‡ä»¶"""
        if not self.requirements_file.exists():
            raise FileNotFoundError(f"requirements.txtæ–‡ä»¶ä¸å­˜åœ¨: {self.requirements_file}")

        packages = []
        index_url = None

        with open(self.requirements_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                if line.startswith('--index-url'):
                    index_url = line.split('--index-url')[1].strip()
                    continue

                # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                if not line:
                    continue

                packages.append(line)

        return packages, index_url

    def check_package_installed(self, package: str) -> bool:
        """æ£€æŸ¥åŒ…æ˜¯å¦å·²å®‰è£…"""
        # ç§»é™¤ç‰ˆæœ¬çº¦æŸè¿›è¡Œæ¯”è¾ƒ
        package_name = package.split('>=')[0].split('==')[0].split('<')[0].strip()

        # ç‰¹æ®Šå¤„ç†torchåŒ…
        if package_name.lower() in ['torch', 'torchvision', 'torchaudio']:
            # æ£€æŸ¥torchç›¸å…³åŒ…çš„å®é™…å¯¼å…¥å
            if package_name.lower() == 'torch':
                import_name = 'torch'
            elif package_name.lower() == 'torchvision':
                import_name = 'torchvision'
            elif package_name.lower() == 'torchaudio':
                import_name = 'torchaudio'
            else:
                import_name = package_name
        else:
            import_name = package_name

        returncode, stdout, stderr = self.run_command([
            sys.executable, '-c', f'import {import_name}'
        ], capture_output=True)

        return returncode == 0

    def install_dependencies(self) -> bool:
        """æ£€æŸ¥å¹¶å®‰è£…ä¾èµ–"""
        self.log("ğŸ” æ£€æŸ¥Pythonä¾èµ–...", "BLUE")

        try:
            required_packages, index_url = self.parse_requirements()
        except Exception as e:
            self.log(f"âŒ è§£ærequirements.txtå¤±è´¥: {e}", "RED")
            return False

        missing_packages = []
        total_packages = len(required_packages)

        for package in required_packages:
            package_name = package.split('>=')[0].split('==')[0].split('<')[0].strip()

            if self.check_package_installed(package_name):
                self.log(f"âœ… {package_name}", "GREEN")
            else:
                self.log(f"ğŸ“¦ {package_name} (å¾…å®‰è£…)", "YELLOW")
                missing_packages.append(package)

        if not missing_packages:
            self.log(f"âœ… æ‰€æœ‰ä¾èµ–å·²å®‰è£… ({total_packages}/{total_packages})", "GREEN")
            return True

        self.log(f"ğŸ“¥ å®‰è£…ç¼ºå¤±ä¾èµ– ({len(missing_packages)}/{total_packages})...", "BLUE")

        # æ„å»ºpip installå‘½ä»¤
        pip_cmd = [sys.executable, '-m', 'pip', 'install']

        # ç‰¹æ®Šå¤„ç†torchåŒ…
        torch_packages = []
        other_packages = []

        for package in missing_packages:
            if 'torch' in package.lower():
                torch_packages.append(package)
            else:
                other_packages.append(package)

        # å¦‚æœæ²¡æœ‰åœ¨requirements.txtä¸­æ‰¾åˆ°torchåŒ…ï¼Œæ‰‹åŠ¨æ·»åŠ 
        if not torch_packages:
            torch_packages = ['torch>=2.2.2', 'torchvision>=0.17.2', 'torchaudio>=2.2.2']

        # å…ˆå®‰è£…étorchåŒ…
        if other_packages:
            cmd = pip_cmd + other_packages
            self.log(f"æ‰§è¡Œå‘½ä»¤: {' '.join(cmd)}", "CYAN")
            returncode, stdout, stderr = self.run_command(cmd, capture_output=True)
            if returncode != 0:
                self.log(f"âš ï¸  étorchåŒ…å®‰è£…å¤±è´¥: {stderr}", "YELLOW")
                self.log(f"stdout: {stdout}", "YELLOW")
            else:
                self.log("âœ… étorchåŒ…å®‰è£…æˆåŠŸ", "GREEN")

        # å•ç‹¬å®‰è£…torchåŒ…
        if torch_packages:
            torch_cmd = pip_cmd + ['--index-url', 'https://download.pytorch.org/whl/cpu'] + torch_packages
            self.log(f"æ‰§è¡Œtorchå‘½ä»¤: {' '.join(torch_cmd)}", "CYAN")
            returncode, stdout, stderr = self.run_command(torch_cmd, capture_output=True)
            if returncode != 0:
                self.log(f"âš ï¸  torchåŒ…å®‰è£…å¤±è´¥: {stderr}", "YELLOW")
                self.log(f"torch stdout: {stdout}", "YELLOW")
                self.log("   å°è¯•å¤‡ç”¨å®‰è£…æ–¹å¼...", "YELLOW")
                # å°è¯•ç®€å•å®‰è£…
                simple_torch_cmd = pip_cmd + ['torch', 'torchvision', 'torchaudio', '--index-url', 'https://download.pytorch.org/whl/cpu']
                self.log(f"æ‰§è¡Œå¤‡ç”¨torchå‘½ä»¤: {' '.join(simple_torch_cmd)}", "CYAN")
                returncode2, stdout2, stderr2 = self.run_command(simple_torch_cmd, capture_output=True)
                if returncode2 != 0:
                    self.log(f"âš ï¸  å¤‡ç”¨torchå®‰è£…ä¹Ÿå¤±è´¥: {stderr2}", "YELLOW")
                    self.log(f"å¤‡ç”¨torch stdout: {stdout2}", "YELLOW")
                else:
                    self.log("âœ… å¤‡ç”¨torchå®‰è£…æˆåŠŸ", "GREEN")

        # æ£€æŸ¥æœ€ç»ˆå®‰è£…ç»“æœ
        final_missing = []
        for package in missing_packages:
            package_name = package.split('>=')[0].split('==')[0].split('<')[0].strip()
            if not self.check_package_installed(package_name):
                final_missing.append(package_name)

        if not final_missing:
            self.log("âœ… ä¾èµ–å®‰è£…æˆåŠŸ", "GREEN")
            return True
        else:
            self.log(f"âš ï¸  ä»¥ä¸‹åŒ…å®‰è£…å¤±è´¥: {', '.join(final_missing)}", "YELLOW")
            self.log("   ç³»ç»Ÿå°†ç»§ç»­è¿è¡Œï¼Œä½†æŸäº›åŠŸèƒ½å¯èƒ½å—é™", "YELLOW")
            return True

    def start_services(self) -> bool:
        """å¯åŠ¨æ‰€æœ‰æœåŠ¡"""
        self.log("ğŸš€ å¯åŠ¨å®Œæ•´ç³»ç»Ÿ...", "BLUE")

        # å¯åŠ¨ç›‘æ§æœåŠ¡
        self.log("1. å¯åŠ¨ç›‘æ§æœåŠ¡...")
        monitor_cmd = [
            sys.executable, str(self.project_root / "src" / "backend" / "monitor_app.py")
        ]

        try:
            monitor_process = subprocess.Popen(
                monitor_cmd,
                cwd=self.project_root,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            self.log(f"âœ… ç›‘æ§æœåŠ¡å·²å¯åŠ¨ (PID: {monitor_process.pid})", "GREEN")
        except Exception as e:
            self.log(f"âŒ ç›‘æ§æœåŠ¡å¯åŠ¨å¤±è´¥: {e}", "RED")
            return False

        # ç­‰å¾…ç›‘æ§æœåŠ¡å¯åŠ¨
        import time
        time.sleep(3)

        # æ£€æŸ¥ç›‘æ§æœåŠ¡æ˜¯å¦å¯åŠ¨æˆåŠŸ
        try:
            import requests
            response = requests.get(f"http://0.0.0.0:{self.monitor_port}/health", timeout=5)
            if response.status_code == 200:
                self.log("âœ… ç›‘æ§æœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡", "GREEN")
            else:
                self.log(f"âš ï¸  ç›‘æ§æœåŠ¡å“åº”å¼‚å¸¸: {response.status_code}", "YELLOW")
        except ImportError:
            self.log("âš ï¸  requestsæ¨¡å—æœªå®‰è£…ï¼Œè·³è¿‡å¥åº·æ£€æŸ¥", "YELLOW")
            # ç®€å•æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
            if monitor_process.poll() is None:
                self.log("âœ… ç›‘æ§æœåŠ¡è¿›ç¨‹è¿è¡Œä¸­", "GREEN")
            else:
                self.log("âŒ ç›‘æ§æœåŠ¡è¿›ç¨‹å·²é€€å‡º", "RED")
                return False
        except:
            self.log("âš ï¸  ç›‘æ§æœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œä½†ç»§ç»­æ‰§è¡Œ", "YELLOW")

        # å¯åŠ¨GUIç•Œé¢
        self.log("2. å¯åŠ¨GUIç•Œé¢...")
        gui_cmd = [
            sys.executable, str(self.project_root / "src" / "gui.py")
        ]

        try:
            gui_process = subprocess.Popen(
                gui_cmd,
                cwd=self.project_root,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            self.log(f"âœ… GUIç•Œé¢å·²å¯åŠ¨ (PID: {gui_process.pid})", "GREEN")
        except Exception as e:
            self.log(f"âŒ GUIç•Œé¢å¯åŠ¨å¤±è´¥: {e}", "RED")
            return False

        # å¯åŠ¨è‡ªåŠ¨åŒ–ç›‘æ§
        self.log("3. å¯åŠ¨è‡ªåŠ¨åŒ–ç›‘æ§...")
        self._start_automated_monitoring()

        # å¯åŠ¨å®æ—¶çŠ¶æ€ç›‘æ§
        self.log("4. å¯åŠ¨å®æ—¶çŠ¶æ€ç›‘æ§...")
        self._start_realtime_monitoring()

        # æ‰“å¼€æµè§ˆå™¨
        self.log("5. æ‰“å¼€æµè§ˆå™¨...")
        self._open_browser(f"http://0.0.0.0:{self.monitor_port}")

        self.log("ğŸ‰ å®Œæ•´ç³»ç»Ÿå¯åŠ¨æˆåŠŸï¼", "GREEN")
        self.log(f"ğŸ“Š ç›‘æ§é¡µé¢: http://0.0.0.0:{self.monitor_port}", "CYAN")
        self.log("ğŸ–¥ï¸  GUIç•Œé¢å·²å¯åŠ¨", "CYAN")
        self.log("ğŸ“ˆ è‡ªåŠ¨åŒ–ç›‘æ§å·²å¯åŠ¨", "CYAN")
        self.log("ğŸŒ æµè§ˆå™¨å·²è‡ªåŠ¨æ‰“å¼€", "CYAN")

        return True

    def _start_automated_monitoring(self) -> None:
        """å¯åŠ¨è‡ªåŠ¨åŒ–ç›‘æ§"""
        monitor_scripts = [
            ("scripts/monitor/monitor.py", ["--json", "--interval", "30"]),
            ("scripts/monitor/api_health_check.py", ["--interval", "60"]),
            ("scripts/monitor/deployment_progress.py", ["--watch"])
        ]

        for script_path, args in monitor_scripts:
            script_file = self.project_root / script_path
            if script_file.exists():
                try:
                    cmd = [sys.executable, str(script_file)] + args
                    process = subprocess.Popen(
                        cmd,
                        cwd=self.project_root,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE
                    )
                    self.log(f"âœ… {script_path} å·²å¯åŠ¨ (PID: {process.pid})", "GREEN")
                except Exception as e:
                    self.log(f"âš ï¸  {script_path} å¯åŠ¨å¤±è´¥: {e}", "YELLOW")

    def _start_realtime_monitoring(self) -> None:
        """å¯åŠ¨å®æ—¶çŠ¶æ€ç›‘æ§"""
        status_file = self.project_root / ".ar_system_status"

        # åˆ›å»ºåˆå§‹çŠ¶æ€æ–‡ä»¶
        initial_status = {
            "status": "running",
            "timestamp": int(time.time()),
            "services": {
                "monitor": "starting",
                "gui": "starting",
                "api": "unknown"
            },
            "health": {
                "overall": "starting"
            }
        }

        with open(status_file, 'w') as f:
            json.dump(initial_status, f, indent=2)

        self.log("âœ… å®æ—¶çŠ¶æ€ç›‘æ§å·²å¯åŠ¨", "GREEN")

    def _open_browser(self, url: str) -> None:
        """æ‰“å¼€æµè§ˆå™¨"""
        browsers = [
            ("google-chrome", ["--new-window", url]),
            ("chromium-browser", ["--new-window", url]),
            ("firefox", ["--new-window", url]),
            ("safari", ["--new-window", url]),
            ("xdg-open", [url])
        ]

        for browser, args in browsers:
            try:
                subprocess.run([browser] + args, check=True, timeout=5)
                self.log(f"âœ… æµè§ˆå™¨å·²æ‰“å¼€: {url}", "GREEN")
                return
            except:
                continue

        self.log(f"âš ï¸  æœªæ‰¾åˆ°å¯ç”¨æµè§ˆå™¨ï¼Œè¯·æ‰‹åŠ¨æ‰“å¼€: {url}", "YELLOW")

    def run(self) -> bool:
        """ä¸»è¿è¡Œé€»è¾‘"""
        try:
            # æ˜¾ç¤ºç¯å¢ƒä¿¡æ¯
            env_type = "ğŸ³ å®¹å™¨ç¯å¢ƒ" if self.is_container else "ğŸ  æœ¬åœ°ç¯å¢ƒ"
            venv_status = "âœ… å­˜åœ¨" if self.venv_path.exists() else "âŒ ä¸å­˜åœ¨"

            self.log(f"ğŸ“‹ ç¯å¢ƒæ£€æµ‹ç»“æœ:", "PURPLE")
            self.log(f"  è¿è¡Œç¯å¢ƒ: {env_type}", "CYAN")
            self.log(f"  è™šæ‹Ÿç¯å¢ƒ: {venv_status}", "CYAN")
            self.log(f"  é¡¹ç›®è·¯å¾„: {self.project_root}", "CYAN")

            # é…ç½®ç¯å¢ƒå˜é‡
            self.setup_environment_variables()

            # å¤„ç†è™šæ‹Ÿç¯å¢ƒ
            if not self.setup_virtual_environment():
                return False

            # æ£€æŸ¥å¹¶å®‰è£…ä¾èµ–
            if not self.install_dependencies():
                return False

            # å¯åŠ¨æ‰€æœ‰æœåŠ¡
            if not self.start_services():
                return False

            return True

        except Exception as e:
            self.log(f"âŒ å¯åŠ¨è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}", "RED")
            import traceback
            traceback.print_exc()
            return False


def main():
    """ä¸»å‡½æ•°"""
    launcher = ARSystemLauncher()
    success = launcher.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()