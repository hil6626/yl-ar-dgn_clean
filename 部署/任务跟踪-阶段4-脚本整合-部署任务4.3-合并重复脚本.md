# Phase 4 - Task 4.3: Merge Duplicate Scripts - Detailed Deployment Document

**Task ID:** 4.3  
**Task Name:** Merge Duplicate Scripts  
**Priority:** P1 (High)  
**Estimated Hours:** 3 hours  
**Status:** Pending  
**Prerequisites:** Task 4.2 completed

---

## I. Task Objectives

Merge duplicate scripts identified in Task 4.1 to eliminate redundancy and create unified implementations.

## II. Duplicate Scripts to Merge

### 2.1 Merge List

| Duplicate Scripts | Target Merged Script | Strategy |
|-------------------|---------------------|----------|
| health_check.py (2 versions) | scripts/monitor/health_check.py | Unified with mode parameter |
| monitor.py (2 versions) | scripts/monitor/monitor.py | Modular with plugins |
| deploy.sh (2 versions) | scripts/deploy/deploy.sh | Component-aware deployment |
| notify.py (2 versions) | scripts/deploy/notify.py | Multi-channel notifications |
| cleanup.sh (multiple) | scripts/cleanup/cleanup.sh | Unified cleanup with options |

## III. Deployment Content

### 3.1 Unified Health Check Script

#### File: scripts/monitor/health_check.py (Merged)

```python
#!/usr/bin/env python3
"""
Unified Health Check Script
Supports both YL-monitor and general system health checks
"""

import argparse
import json
import logging
import requests
import sys
from pathlib import Path
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('HealthCheck')


class HealthChecker:
    """
    Unified Health Checker
    """

    def __init__(self, mode: str = 'general'):
        self.mode = mode
        self.results = []
        self.config = self._load_config()

    def _load_config(self) -> Dict:
        """Load configuration based on mode"""
        if self.mode == 'yl-monitor':
            return {
                'services': [
                    {'name': 'YL-monitor', 'url': 'http://localhost:5500/api/health', 'type': 'api'},
                    {'name': 'Database', 'url': 'localhost:5432', 'type': 'tcp'},
                ]
            }
        else:  # general
            return {
                'services': [
                    {'name': 'YL-monitor', 'url': 'http://localhost:5500/api/health', 'type': 'api'},
                    {'name': 'AR-backend', 'url': 'http://localhost:5501/health', 'type': 'api'},
                    {'name': 'User GUI', 'url': 'http://localhost:5502/health', 'type': 'api'},
                ]
            }

    def check_api(self, name: str, url: str) -> Dict:
        """Check API endpoint"""
        try:
            response = requests.get(url, timeout=5)
            healthy = response.status_code == 200
            return {
                'name': name,
                'type': 'api',
                'url': url,
                'healthy': healthy,
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds()
            }
        except Exception as e:
            return {
                'name': name,
                'type': 'api',
                'url': url,
                'healthy': False,
                'error': str(e)
            }

    def check_tcp(self, name: str, address: str) -> Dict:
        """Check TCP port"""
        import socket
        try:
            host, port = address.split(':')
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((host, int(port)))
            sock.close()
            return {
                'name': name,
                'type': 'tcp',
                'address': address,
                'healthy': result == 0
            }
        except Exception as e:
            return {
                'name': name,
                'type': 'tcp',
                'address': address,
                'healthy': False,
                'error': str(e)
            }

    def run_checks(self) -> List[Dict]:
        """Run all health checks"""
        for service in self.config.get('services', []):
            check_type = service.get('type', 'api')

            if check_type == 'api':
                result = self.check_api(service['name'], service['url'])
            elif check_type == 'tcp':
                result = self.check_tcp(service['name'], service['url'])
            else:
                result = {
                    'name': service['name'],
                    'healthy': False,
                    'error': f'Unknown check type: {check_type}'
                }

            self.results.append(result)

        return self.results

    def generate_report(self) -> str:
        """Generate health check report"""
        lines = []
        lines.append("# Health Check Report")
        lines.append(f"**Mode:** {self.mode}")
        lines.append(f"**Timestamp:** {__import__('datetime').datetime.now().isoformat()}")
        lines.append("")

        all_healthy = True
        for result in self.results:
            status = "✓" if result['healthy'] else "✗"
            lines.append(f"{status} {result['name']}")

            if not result['healthy']:
                all_healthy = False
                if 'error' in result:
                    lines.append(f"  Error: {result['error']}")

            if 'response_time' in result:
                lines.append(f"  Response time: {result['response_time']:.3f}s")

        lines.append("")
        lines.append(f"**Overall:** {'HEALTHY' if all_healthy else 'UNHEALTHY'}")

        return '\n'.join(lines)


def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Unified Health Check')
    parser.add_argument('--mode', choices=['general', 'yl-monitor'],
                       default='general', help='Check mode')
    parser.add_argument('--json', action='store_true', help='Output as JSON')
    parser.add_argument('--service', help='Check specific service only')

    args = parser.parse_args()

    checker = HealthChecker(mode=args.mode)

    if args.service:
        # Check specific service
        checker.config['services'] = [
            s for s in checker.config['services']
            if s['name'].lower() == args.service.lower()
        ]

    results = checker.run_checks()

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        print(checker.generate_report())

    # Exit code
    sys.exit(0 if all(r['healthy'] for r in results) else 1)


if __name__ == '__main__':
    main()
```

### 3.2 Merge Script Tool

#### File: scripts/tools/merge_scripts.py

```python
#!/usr/bin/env python3
"""
Script Merger Tool
Merges duplicate scripts intelligently
"""

import argparse
import shutil
from pathlib import Path
from typing import List, Tuple


class ScriptMerger:
    """
    Script Merger
    """

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.merges = []

    def find_duplicates(self) -> List[Tuple[Path, Path]]:
        """Find duplicate scripts by name"""
        duplicates = []
        seen = {}

        for script in self.project_root.rglob('*.py'):
            if '__pycache__' in str(script):
                continue

            name = script.name
            if name in seen:
                duplicates.append((seen[name], script))
            else:
                seen[name] = script

        return duplicates

    def merge_scripts(self, script1: Path, script2: Path, output: Path):
        """
        Merge two scripts into one
        """
        print(f"Merging:\n  1: {script1}\n  2: {script2}\n  ->: {output}")

        # Read both scripts
        with open(script1) as f:
            content1 = f.read()

        with open(script2) as f:
            content2 = f.read()

        # Create merged content
        merged = self._create_merged_content(content1, content2, script1.name)

        # Write merged script
        output.parent.mkdir(parents=True, exist_ok=True)
        with open(output, 'w') as f:
            f.write(merged)

        # Backup originals
        shutil.copy(script1, str(script1) + '.backup')
        shutil.copy(script2, str(script2) + '.backup')

        print(f"  Created: {output}")
        print(f"  Backed up originals")

    def _create_merged_content(self, content1: str, content2: str, filename: str) -> str:
        """
        Create merged script content
        """
        if filename.endswith('.py'):
            return self._merge_python(content1, content2)
        else:
            return self._merge_shell(content1, content2)

    def _merge_python(self, content1: str, content2: str) -> str:
        """Merge Python scripts"""
        lines = [
            "#!/usr/bin/env python3",
            "\"\"\"",
            "Merged Script",
            "Combines functionality from multiple sources",
            "\"\"\"",
            "",
            "import argparse",
            "",
            "MODE = 'general'  # or 'yl-monitor'",
            "",
            "# Source 1 functionality",
            content1,
            "",
            "# Source 2 functionality",
            content2,
            "",
            "if __name__ == '__main__':",
            "    main()",
        ]
        return '\n'.join(lines)

    def _merge_shell(self, content1: str, content2: str) -> str:
        """Merge shell scripts"""
        lines = [
            "#!/bin/bash",
            "# Merged Script",
            "",
            "MODE=${MODE:-general}",
            "",
            "# Source 1",
            content1,
            "",
            "# Source 2",
            content2,
        ]
        return '\n'.join(lines)


def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Merge duplicate scripts')
    parser.add_argument('--find', action='store_true', help='Find duplicates only')
    parser.add_argument('--merge', nargs=3, metavar=('FILE1', 'FILE2', 'OUTPUT'),
                       help='Merge two specific files')

    args = parser.parse_args()

    project_root = Path(__file__).parent.parent.parent
    merger = ScriptMerger(project_root)

    if args.find:
        duplicates = merger.find_duplicates()
        print(f"Found {len(duplicates)} potential duplicates:")
        for dup1, dup2 in duplicates:
            print(f"  - {dup1.name}")
            print(f"    {dup1}")
            print(f"    {dup2}")

    elif args.merge:
        script1 = Path(args.merge[0])
        script2 = Path(args.merge[1])
        output = Path(args.merge[2])
        merger.merge_scripts(script1, script2, output)


if __name__ == '__main__':
    main()
```

## IV. Deployment Steps

```bash
# 1. Create merged health check
# Edit scripts/monitor/health_check.py

# 2. Create merge tool
# Edit scripts/tools/merge_scripts.py

# 3. Find duplicates
python3 scripts/tools/merge_scripts.py --find

# 4. Merge specific duplicates
python3 scripts/tools/merge_scripts.py --merge \
    scripts/monitor/health_check.py \
    YL-monitor/scripts/monitor/health_check.py \
    scripts/monitor/health_check_merged.py

# 5. Test merged script
python3 scripts/monitor/health_check.py --mode general
python3 scripts/monitor/health_check.py --mode yl-monitor

# 6. Replace originals after validation
mv scripts/monitor/health_check_merged.py scripts/monitor/health_check.py
rm YL-monitor/scripts/monitor/health_check.py
```

## V. Verification Checklist

- [ ] Unified health check created
- [ ] Merge tool created
- [ ] Duplicates identified
- [ ] Merged scripts tested
- [ ] Originals backed up
- [ ] Validation passes

## VI. Next Step

After completing this task, proceed to **Task 4.4: Create Unified Script Entry Point**

View document: `部署/任务跟踪-阶段4-脚本整合-部署任务4.4-创建统一脚本入口.md`
