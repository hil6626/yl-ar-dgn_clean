# Phase 4 - Task 4.6: Create Unified Logging - Detailed Deployment Document

**Task ID:** 4.6  
**Task Name:** Create Unified Logging  
**Priority:** P2 (Medium)  
**Estimated Hours:** 2 hours  
**Status:** Pending  
**Prerequisites:** Task 4.5 completed

---

## I. Task Objectives

Create a unified logging system for all scripts to ensure consistent log format and centralized log management.

## II. Deployment Content

### 2.1 Unified Logging Module

#### File: scripts/lib/logger.py

```python
#!/usr/bin/env python3
"""
Unified Logging Module
Provides consistent logging across all scripts
"""

import logging
import sys
import json
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any


class UnifiedLogger:
    """
    Unified Logger
    """

    LOG_FORMAT = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
    DATE_FORMAT = "%Y-%m-%d %H:%M:%S"

    def __init__(self, name: str, log_dir: Optional[Path] = None):
        self.name = name
        self.log_dir = log_dir or Path(__file__).parent.parent.parent / 'logs'
        self.log_dir.mkdir(parents=True, exist_ok=True)

        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.DEBUG)

        # Clear existing handlers
        self.logger.handlers = []

        # Console handler
        console = logging.StreamHandler(sys.stdout)
        console.setLevel(logging.INFO)
        console.setFormatter(logging.Formatter(self.LOG_FORMAT, self.DATE_FORMAT))
        self.logger.addHandler(console)

        # File handler
        log_file = self.log_dir / f"{name.replace('.', '_')}.log"
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(logging.Formatter(self.LOG_FORMAT, self.DATE_FORMAT))
        self.logger.addHandler(file_handler)

        # JSON handler for structured logging
        json_file = self.log_dir / f"{name.replace('.', '_')}.jsonl"
        json_handler = logging.FileHandler(json_file)
        json_handler.setLevel(logging.DEBUG)
        json_handler.setFormatter(JsonFormatter())
        self.logger.addHandler(json_handler)

    def debug(self, msg: str, **kwargs):
        self.logger.debug(msg, extra=kwargs)

    def info(self, msg: str, **kwargs):
        self.logger.info(msg, extra=kwargs)

    def warning(self, msg: str, **kwargs):
        self.logger.warning(msg, extra=kwargs)

    def error(self, msg: str, **kwargs):
        self.logger.error(msg, extra=kwargs)

    def critical(self, msg: str, **kwargs):
        self.logger.critical(msg, extra=kwargs)

    def log_operation(self, operation: str, status: str, details: Dict = None):
        """
        Log structured operation
        """
        self.info(f"Operation: {operation} | Status: {status}", 
                  operation=operation, status=status, details=details or {})


class JsonFormatter(logging.Formatter):
    """
    JSON log formatter
    """

    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'source': {
                'file': record.filename,
                'line': record.lineno,
                'function': record.funcName
            }
        }

        # Add extra fields
        for key, value in record.__dict__.items():
            if key not in ['name', 'msg', 'args', 'levelname', 'levelno', 
                          'pathname', 'filename', 'module', 'lineno', 
                          'funcName', 'created', 'msecs', 'relativeCreated',
                          'thread', 'threadName', 'processName', 'process',
                          'getMessage', 'exc_info', 'exc_text', 'stack_info']:
                if not key.startswith('_'):
                    log_data[key] = value

        return json.dumps(log_data, default=str)


# Convenience functions
def get_logger(name: str) -> UnifiedLogger:
    """Get unified logger instance"""
    return UnifiedLogger(name)


# Standard loggers
def script_logger(script_name: str) -> UnifiedLogger:
    """Get logger for a script"""
    return UnifiedLogger(f"scripts.{script_name}")


def component_logger(component: str) -> UnifiedLogger:
    """Get logger for a component"""
    return UnifiedLogger(f"component.{component}")
```

### 2.2 Shell Logging Functions

#### File: scripts/lib/logging.sh

```bash
#!/bin/bash
# Shell Logging Functions

YL_LOG_DIR="${YL_LOG_DIR:-$(dirname "${BASH_SOURCE[0]}")/../../logs}"
YL_LOG_LEVEL="${YL_LOG_LEVEL:-INFO}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure log directory exists
mkdir -p "$YL_LOG_DIR"

# Get script name
YL_SCRIPT_NAME="${YL_SCRIPT_NAME:-$(basename "$0")}"
YL_LOG_FILE="$YL_LOG_DIR/${YL_SCRIPT_NAME%.sh}.log"

# Timestamp
yl_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Log functions
yl_log() {
    local level=$1
    local message=$2
    local timestamp=$(yl_timestamp)
    
    # Console output with color
    case "$level" in
        DEBUG)  echo -e "${CYAN}[DEBUG]${NC} $message" ;;
        INFO)   echo -e "${GREEN}[INFO]${NC} $message" ;;
        WARN)   echo -e "${YELLOW}[WARN]${NC} $message" ;;
        ERROR)  echo -e "${RED}[ERROR]${NC} $message" ;;
        FATAL)  echo -e "${RED}[FATAL]${NC} $message" ;;
    esac
    
    # File output
    echo "$timestamp | $level | $YL_SCRIPT_NAME | $message" >> "$YL_LOG_FILE"
}

yl_debug() { [[ "$YL_LOG_LEVEL" == "DEBUG" ]] && yl_log "DEBUG" "$1"; }
yl_info() { yl_log "INFO" "$1"; }
yl_warn() { yl_log "WARN" "$1"; }
yl_error() { yl_log "ERROR" "$1"; }
yl_fatal() { yl_log "FATAL" "$1"; exit 1; }

# Operation logging
yl_log_operation() {
    local operation=$1
    local status=$2
    local details="${3:-}"
    
    yl_info "Operation: $operation | Status: $status"
    if [[ -n "$details" ]]; then
        yl_debug "Details: $details"
    fi
}

# Section header
yl_section() {
    local title=$1
    echo ""
    echo "========================================"
    echo "  $title"
    echo "========================================"
    yl_info "Starting: $title"
}

# Progress indicator
yl_progress() {
    local current=$1
    local total=$2
    local message="${3:-Progress}"
    
    local percent=$((current * 100 / total))
    local bar_length=30
    local filled=$((percent * bar_length / 100))
    
    printf "\r%s: [" "$message"
    printf "%0.s#" $(seq 1 $filled)
    printf "%0.s-" $(seq $((filled + 1)) $bar_length)
    printf "] %d%% (%d/%d)" "$percent" "$current" "$total"
    
    if [[ $current -eq $total ]]; then
        echo ""
        yl_info "$message completed"
    fi
}

# Example usage:
# source "$(dirname "$0")/../lib/logging.sh"
# yl_info "Starting deployment"
# yl_log_operation "deploy" "started"
```

## III. Deployment Steps

```bash
# 1. Create logs directory
mkdir -p logs

# 2. Create Python logger
mkdir -p scripts/lib
# Edit scripts/lib/logger.py

# 3. Create shell logging
# Edit scripts/lib/logging.sh

# 4. Test Python logger
python3 -c "
from scripts.lib.logger import get_logger, script_logger
logger = script_logger('test')
logger.info('Test message')
logger.log_operation('test_op', 'success', {'key': 'value'})
"

# 5. Test shell logging
source scripts/lib/logging.sh
yl_info "Test message"
yl_log_operation "test_op" "success" "details here"

# 6. Check log files
ls -la logs/
cat logs/test.log
cat logs/test.jsonl
```

## IV. Verification Checklist

- [ ] Python logger created
- [ ] Shell logging created
- [ ] Log directory created
- [ ] Console output works
- [ ] File logging works
- [ ] JSON logging works
- [ ] Operation logging works

## V. Next Step

After completing this task, proceed to **Task 4.7: Create Unified Error Handling**

View document: `部署/任务跟踪-阶段4-脚本整合-部署任务4.7-创建统一错误处理.md`
