# 7. 联调测试方案

**版本:** 1.0.0  
**创建日期:** 2026-02-09  
**状态:** 待执行

## 一、目标

完成整个项目的端到端联调测试，验证：
1. 各组件间通信正常
2. 监控整合功能完整
3. User GUI 功能正常
4. 脚本整合有效
5. 规则架构运行正常

## 二、测试范围

### 2.1 测试对象

| 组件 | 版本 | 测试重点 |
|------|------|----------|
| YL-monitor | 1.0.6 | 监控功能、API、WebSocket |
| AR-backend | 2.0.0 | 监控端点、服务状态 |
| User GUI | 2.0.0 | 功能完整、通信正常 |
| Scripts | 2.1.0 | 统一入口、功能完整 |
| Rules | 1.0.0 | 规则引擎、验证功能 |

### 2.2 测试场景

```
┌─────────────────────────────────────────────────────────────┐
│                     联调测试场景                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  场景1: 完整启动流程                                         │
│  ├── 启动 YL-monitor                                        │
│  ├── 启动 AR-backend 监控服务                                │
│  ├── 启动 User GUI                                         │
│  └── 验证监控面板显示所有组件                                 │
│                                                             │
│  场景2: 功能操作测试                                         │
│  ├── User GUI 启动视频                                       │
│  ├── User GUI 加载人脸图片                                   │
│  ├── User GUI 启动音频                                       │
│  └── 验证 YL-monitor 收到状态上报                            │
│                                                             │
│  场景3: 故障模拟测试                                         │
│  ├── 停止 AR-backend                                        │
│  ├── 验证 YL-monitor 告警                                    │
│  ├── 恢复 AR-backend                                        │
│  └── 验证告警恢复                                            │
│                                                             │
│  场景4: 脚本操作测试                                         │
│  ├── 执行统一入口脚本查看状态                                  │
│  ├── 执行部署脚本                                           │
│  ├── 执行验证脚本                                           │
│  └── 验证脚本功能正常                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 三、测试环境

### 3.1 硬件要求

- CPU: 4核+
- 内存: 8GB+
- 磁盘: 20GB+ 可用空间
- 网络: 本地回环网络正常

### 3.2 软件要求

- OS: Ubuntu 20.04+ / Windows 10+
- Python: 3.8+
- Node.js: 14+ (用于规则引擎)
- Docker: 20.10+ (可选)

### 3.3 端口分配

| 服务 | 端口 | 用途 |
|------|------|------|
| YL-monitor | 5500 | 主监控平台 |
| AR-backend 监控 | 5501 | 健康检查端点 |
| User GUI 状态 | 5502 | 状态上报端点 |

## 四、测试用例

### 4.1 阶段1: 监控整合测试 (任务13.1)

#### 用例1.1: YL-monitor 启动测试

**目的:** 验证 YL-monitor 能正常启动

**步骤:**
1. 进入 YL-monitor 目录
2. 安装依赖: `pip install -r requirements.txt`
3. 启动服务: `python -m app.main` 或 `uvicorn app.main:app --port 5500`

**预期结果:**
- 服务启动无错误
- 日志显示所有组件初始化成功
- 访问 http://localhost:5500 显示平台界面

**验证命令:**
```bash
curl http://localhost:5500/api/health
# 预期: {"status": "healthy", "version": "1.0.6"}
```

#### 用例1.2: AR-backend 监控服务测试

**目的:** 验证 AR-backend 监控服务正常

**步骤:**
1. 创建 AR-backend/monitor_server.py
2. 启动监控服务: `python AR-backend/monitor_server.py`

**预期结果:**
- 服务在 5501 端口启动
- 健康检查端点可用

**验证命令:**
```bash
curl http://localhost:5501/health
# 预期: {"status": "healthy", "service": "ar-backend"}
```

#### 用例1.3: User GUI 状态服务测试

**目的:** 验证 User GUI 能上报状态

**步骤:**
1. 创建 user/status_reporter.py
2. 在 User GUI 中集成状态上报
3. 启动 User GUI

**预期结果:**
- 状态服务在 5502 端口可用
- 定时向 YL-monitor 上报心跳

**验证命令:**
```bash
curl http://localhost:5502/status
# 预期: {"status": "running", "gui": "active"}
```

#### 用例1.4: 统一监控面板测试

**目的:** 验证 YL-monitor 能显示所有节点

**步骤:**
1. 确保所有服务已启动
2. 访问 YL-monitor 的 AR 监控页面
3. 查看节点列表

**预期结果:**
- 显示 AR-backend 节点，状态为 online
- 显示 User GUI 节点，状态为 online
- 节点信息实时更新

**验证方法:**
```bash
curl http://localhost:5500/api/ar/nodes
# 预期: 返回包含 ar-backend 和 user-gui 的节点列表
```

### 4.2 阶段2: User GUI 功能测试 (任务13.2)

#### 用例2.1: GUI 启动测试

**目的:** 验证 User GUI 能正常启动

**步骤:**
1. 修复所有导入路径
2. 创建 user/main.py
3. 执行: `python user/main.py`

**预期结果:**
- GUI 窗口正常显示
- 无导入错误
- 状态栏显示就绪

**验证方法:**
- 截图确认界面正常
- 检查日志无错误

#### 用例2.2: 视频功能测试

**目的:** 验证视频功能正常

**步骤:**
1. 点击"启动视频"按钮
2. 观察视频流显示
3. 等待 30 秒
4. 点击"停止视频"

**预期结果:**
- 视频流正常显示
- FPS 统计显示正常
- 无卡顿或崩溃

**验证方法:**
- 观察视频画面
- 检查 FPS 标签更新

#### 用例2.3: 人脸合成功能测试

**目的:** 验证人脸合成功能正常

**步骤:**
1. 点击"加载图片"
2. 选择一张人脸图片
3. 观察源人脸显示
4. 选择合成算法
5. 调节参数

**预期结果:**
- 图片正常加载
- 算法选择正常
- 参数调节生效

**验证方法:**
- 确认图片显示在源人脸区域
- 检查算法下拉框可用

#### 用例2.4: 音频功能测试

**目的:** 验证音频处理功能正常

**步骤:**
1. 选择音效效果
2. 调节音调
3. 点击"启动音频"
4. 等待 10 秒
5. 点击"停止音频"

**预期结果:**
- 音频处理启动成功
- 参数调节生效
- 无异常报错

**验证方法:**
- 检查日志显示音频启动成功
- 确认按钮状态变化

#### 用例2.5: 监控链接测试

**目的:** 验证能打开监控面板

**步骤:**
1. 点击"监控面板"按钮
2. 观察浏览器是否打开

**预期结果:**
- 浏览器打开 YL-monitor 页面
- 显示正确的监控数据

**验证方法:**
- 确认浏览器访问 http://localhost:5500

### 4.3 阶段3: 故障模拟测试 (任务13.3)

#### 用例3.1: AR-backend 故障测试

**目的:** 验证故障检测和告警

**步骤:**
1. 确保所有服务正常运行
2. 在 YL-monitor 确认 AR-backend 状态为 online
3. 停止 AR-backend 监控服务
4. 等待 60 秒
5. 检查 YL-monitor 告警
6. 恢复 AR-backend 服务

**预期结果:**
- 停止后 30-60 秒内状态变为 offline
- YL-monitor 产生告警
- 恢复后状态变为 online
- 告警恢复通知

**验证方法:**
```bash
# 停止服务
pkill -f "monitor_server.py"

# 检查状态
curl http://localhost:5500/api/ar/nodes/ar-backend

# 恢复服务
python AR-backend/monitor_server.py &
```

#### 用例3.2: User GUI 故障测试

**目的:** 验证 User GUI 故障检测

**步骤:**
1. 确保 User GUI 运行
2. 关闭 User GUI
3. 等待心跳超时
4. 检查 YL-monitor 状态

**预期结果:**
- 关闭后状态变为 offline
- YL-monitor 显示离线状态

### 4.4 阶段4: 脚本整合测试 (任务13.4)

#### 用例4.1: 统一入口测试

**目的:** 验证统一入口脚本可用

**步骤:**
1. 创建 scripts/yl-ar-dgn.sh
2. 执行: `./scripts/yl-ar-dgn.sh help`
3. 执行: `./scripts/yl-ar-dgn.sh status`

**预期结果:**
- help 显示帮助信息
- status 显示项目状态

**验证命令:**
```bash
./scripts/yl-ar-dgn.sh help
./scripts/yl-ar-dgn.sh status
```

#### 用例4.2: 部署脚本测试

**目的:** 验证部署脚本功能

**步骤:**
1. 执行: `./scripts/yl-ar-dgn.sh deploy --dry-run`
2. 执行: `./scripts/yl-ar-dgn.sh deploy yl-monitor`

**预期结果:**
- dry-run 显示部署计划
- 部署命令执行成功

#### 用例4.3: 验证脚本测试

**目的:** 验证验证脚本功能

**步骤:**
1. 执行: `./scripts/yl-ar-dgn.sh validate`

**预期结果:**
- 验证所有组件
- 输出验证报告

### 4.5 阶段5: 规则架构测试 (任务13.5)

#### 用例5.1: 规则加载测试

**目的:** 验证规则引擎能加载所有规则

**步骤:**
1. 执行: `node rules/index.js`

**预期结果:**
- 成功加载 L1-L5 规则
- 无解析错误

#### 用例5.2: 规则验证测试

**目的:** 验证规则验证功能

**步骤:**
1. 调用规则引擎的 validate 方法
2. 检查验证结果

**预期结果:**
- 所有规则验证通过
- 无冲突或错误

#### 用例5.3: 规则执行测试

**目的:** 验证规则执行功能

**步骤:**
1. 执行阶段 P1 规则
2. 检查执行结果

**预期结果:**
- 返回正确的执行计划
- 步骤清晰可执行

### 4.6 阶段6: 端到端测试 (任务13.6)

#### 用例6.1: 完整工作流程测试

**目的:** 验证完整工作流程

**步骤:**
1. 清理环境，停止所有服务
2. 使用脚本启动所有服务
3. 打开 User GUI 进行操作
4. 在 YL-monitor 观察状态
5. 模拟故障并观察告警
6. 恢复服务并验证

**预期结果:**
- 所有步骤无阻塞
- 数据流正确
- 状态同步及时

#### 用例6.2: 性能测试

**目的:** 验证系统性能

**步骤:**
1. 启动所有服务
2. 使用 User GUI 进行视频处理
3. 监控资源占用
4. 测试并发操作

**预期结果:**
- CPU 占用 < 80%
- 内存占用 < 4GB
- 响应时间 < 100ms

## 五、测试工具

### 5.1 自动化测试脚本

**文件:** `test/integration/test_full_workflow.py`

```python
#!/usr/bin/env python3
"""
端到端联调测试
"""

import requests
import time
import subprocess
import pytest

class IntegrationTest:
    def setup_class(self):
        """测试前准备"""
        self.yl_monitor_url = "http://localhost:5500"
        self.ar_backend_url = "http://localhost:5501"
        self.user_gui_url = "http://localhost:5502"
        
    def test_yl_monitor_health(self):
        """测试 YL-monitor 健康"""
        response = requests.get(f"{self.yl_monitor_url}/api/health")
        assert response.status_code == 200
        assert response.json()["status"] == "healthy"
        
    def test_ar_backend_health(self):
        """测试 AR-backend 健康"""
        response = requests.get(f"{self.ar_backend_url}/health")
        assert response.status_code == 200
        
    def test_user_gui_status(self):
        """测试 User GUI 状态"""
        response = requests.get(f"{self.user_gui_url}/status")
        assert response.status_code == 200
        
    def test_monitor_nodes(self):
        """测试监控节点"""
        response = requests.get(f"{self.yl_monitor_url}/api/ar/nodes")
        nodes = response.json()
        assert len(nodes) >= 2  # 至少两个节点
        
    def test_full_workflow(self):
        """测试完整流程"""
        # 1. 检查所有服务健康
        self.test_yl_monitor_health()
        self.test_ar_backend_health()
        self.test_user_gui_status()
        
        # 2. 检查监控节点
        self.test_monitor_nodes()
        
        # 3. 模拟 User GUI 心跳
        heartbeat = {
            "node_id": "user-gui",
            "status": "running",
            "timestamp": time.time()
        }
        response = requests.post(
            f"{self.yl_monitor_url}/api/ar/nodes/user-gui/heartbeat",
            json=heartbeat
        )
        assert response.status_code == 200
        
        print("✓ 端到端测试通过")
```

### 5.2 性能测试脚本

**文件:** `test/performance/performance_test.py`

```python
#!/usr/bin/env python3
"""
性能测试
"""

import time
import psutil
import requests
import statistics

class PerformanceTest:
    def __init__(self):
        self.base_url = "http://localhost:5500"
        self.results = []
        
    def test_api_response_time(self):
        """测试 API 响应时间"""
        times = []
        
        for _ in range(100):
            start = time.time()
            requests.get(f"{self.base_url}/api/health")
            elapsed = time.time() - start
            times.append(elapsed * 1000)  # 转换为毫秒
            
        avg_time = statistics.mean(times)
        max_time = max(times)
        min_time = min(times)
        
        print(f"API 响应时间: 平均={avg_time:.2f}ms, 最大={max_time:.2f}ms, 最小={min_time:.2f}ms")
        
        assert avg_time < 100, f"平均响应时间 {avg_time}ms 超过 100ms"
        
    def test_resource_usage(self):
        """测试资源占用"""
        # 获取系统资源
        cpu = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        
        print(f"CPU: {cpu}%")
        print(f"内存: {memory.percent}% ({memory.used / 1024 / 1024:.0f}MB / {memory.total / 1024 / 1024:.0f}MB)")
        
        assert cpu < 80, f"CPU 占用 {cpu}% 超过 80%"
        assert memory.percent < 80, f"内存占用 {memory.percent}% 超过 80%"
```

## 六、测试计划

### 6.1 测试阶段

| 阶段 | 时间 | 内容 | 负责人 |
|------|------|------|--------|
| 准备 | 0.5天 | 环境准备、测试数据 | 自动化 |
| 阶段1 | 1天 | 监控整合测试 | 开发团队 |
| 阶段2 | 1天 | User GUI 测试 | 开发团队 |
| 阶段3 | 0.5天 | 故障模拟测试 | 测试团队 |
| 阶段4 | 0.5天 | 脚本整合测试 | 开发团队 |
| 阶段5 | 0.5天 | 规则架构测试 | 开发团队 |
| 阶段6 | 1天 | 端到端测试 | 测试团队 |
| 总结 | 0.5天 | 报告生成、问题修复 | 全团队 |

**总计: 5.5天**

### 6.2 测试通过标准

| 指标 | 目标 | 必须 |
|------|------|------|
| 功能测试通过率 | 100% | 是 |
| 性能测试通过率 | 100% | 是 |
| 代码覆盖率 | > 80% | 否 |
| 严重缺陷数 | 0 | 是 |
| 一般缺陷数 | < 5 | 是 |

## 七、问题跟踪

### 7.1 缺陷分级

| 级别 | 定义 | 处理时限 |
|------|------|----------|
| P0 - 致命 | 系统崩溃、数据丢失 | 立即 |
| P1 - 严重 | 主要功能不可用 | 24小时 |
| P2 - 一般 | 次要功能异常 | 3天 |
| P3 - 轻微 | 界面问题、优化建议 | 下次迭代 |

### 7.2 缺陷跟踪表

| ID | 描述 | 级别 | 状态 | 负责人 | 备注 |
|----|------|------|------|--------|------|
| | | | | | |

## 八、测试报告模板

### 8.1 日报模板

```
日期: 2026-02-XX
测试人员: XXX
今日完成:
- 完成 XXX 测试用例 X 个
- 发现缺陷 X 个（P0: X, P1: X, P2: X）

明日计划:
- 执行 XXX 测试

阻塞问题:
- 无 / XXX 问题等待解决
```

### 8.2 最终报告模板

```
YL-AR-DGN 项目联调测试报告

测试时间: 2026-02-XX 至 2026-02-XX
测试范围: 监控整合、User GUI、脚本整合、规则架构
测试环境: Ubuntu 20.04, Python 3.8

测试结果:
- 总用例数: XX
- 通过: XX
- 失败: XX
- 通过率: XX%

缺陷统计:
- P0: X 个
- P1: X 个
- P2: X 个
- P3: X 个

结论:
[通过 / 有条件通过 / 不通过]

建议:
- XXX
```

## 九、执行检查点

- [ ] 检查点1: 测试环境准备完成
- [ ] 检查点2: 阶段1测试通过
- [ ] 检查点3: 阶段2测试通过
- [ ] 检查点4: 阶段3测试通过
- [ ] 检查点5: 阶段4测试通过
- [ ] 检查点6: 阶段5测试通过
- [ ] 检查点7: 阶段6测试通过
- [ ] 检查点8: 测试报告完成

## 十、关联文档

- [3.监控整合方案.md](./3.监控整合方案.md)
- [4.User-GUI优化方案.md](./4.User-GUI优化方案.md)
- [5.规则架构部署.md](./5.规则架构部署.md)
- [6.脚本整合方案.md](./6.脚本整合方案.md)

---

**下一步:** 执行阶段1测试 - 监控整合测试
