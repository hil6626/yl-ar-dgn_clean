# 阶段1 - 任务1.2: User GUI 状态上报实现 - 详细部署文档

**任务ID:** 1.2  
**任务名称:** User GUI 状态上报实现  
**优先级:** P0（阻塞性）  
**预计工时:** 6小时  
**状态:** ✅ 已完成  
**前置依赖:** 任务1.1完成（AR-backend监控服务已创建）

---

## 一、任务目标

为 User GUI 创建状态上报机制，使其能够定时向 YL-monitor 上报运行状态，并提供本地HTTP服务供查询。

## 二、部署内容

### 2.1 创建文件清单

| 序号 | 文件路径 | 文件类型 | 说明 |
|------|----------|----------|------|
| 1 | `user/services/status_reporter.py` | 新建 | 状态上报服务 |
| 2 | `user/services/monitor_client.py` | 新建 | YL-monitor客户端 |
| 3 | `user/services/local_http_server.py` | 新建 | 本地HTTP服务 |
| 4 | `user/config/monitor_config.yaml` | 新建 | 监控配置 |
| 5 | `user/gui/gui.py` | 修改 | 集成状态上报 |
| 6 | `user/main.py` | 修改 | 启动状态服务 |

### 2.2 详细代码实现

#### 文件1: user/services/status_reporter.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
User GUI 状态上报服务
定时向 YL-monitor 上报应用状态
"""

import os
import sys
import time
import json
import logging
import requests
import threading
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('StatusReporter')


class StatusReporter:
    """
    状态上报器
    负责收集User GUI状态并上报到YL-monitor
    """
    
    def __init__(self, config_path: Optional[str] = None):
        self.config = self._load_config(config_path)
        self.running = False
        self.thread: Optional[threading.Thread] = None
        self.last_report_time: Optional[datetime] = None
        self.report_count = 0
        self.error_count = 0
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'UserGUI-StatusReporter/1.0'
        })
        
        # 状态缓存
        self._status_cache: Dict[str, Any] = {}
        self._lock = threading.Lock()
        
    def _load_config(self, config_path: Optional[str]) -> Dict:
        """加载配置"""
        default_config = {
            'monitor_url': 'http://localhost:5500',
            'node_id': 'user-gui',
            'node_name': 'User GUI',
            'report_interval': 30,  # 秒
            'timeout': 5,  # 秒
            'max_retries': 3,
            'retry_delay': 2,  # 秒
            'enabled': True
        }
        
        if config_path and Path(config_path).exists():
            try:
                import yaml
                with open(config_path, 'r', encoding='utf-8') as f:
                    user_config = yaml.safe_load(f)
                    if user_config:
                        default_config.update(user_config)
            except Exception as e:
                logger.error(f"加载配置失败: {e}")
                
        # 环境变量覆盖
        if os.getenv('YL_MONITOR_URL'):
            default_config['monitor_url'] = os.getenv('YL_MONITOR_URL')
        if os.getenv('USER_GUI_NODE_ID'):
            default_config['node_id'] = os.getenv('USER_GUI_NODE_ID')
            
        return default_config
    
    def _collect_status(self) -> Dict[str, Any]:
        """收集当前状态"""
        try:
            import psutil
            
            # 获取进程信息
            process = psutil.Process()
            
            status = {
                'node_id': self.config['node_id'],
                'node_name': self.config['node_name'],
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'status': 'running',
                'version': '2.0.0',
                'uptime': time.time() - process.create_time(),
                'resources': {
                    'cpu_percent': process.cpu_percent(),
                    'memory_mb': process.memory_info().rss / 1024 / 1024,
                    'threads': process.num_threads()
                },
                'gui': {
                    'window_active': True,  # 由GUI更新
                    'video_running': False,  # 由GUI更新
                    'audio_running': False,  # 由GUI更新
                    'face_loaded': False  # 由GUI更新
                }
            }
            
            # 合并GUI更新的状态
            with self._lock:
                status['gui'].update(self._status_cache)
                
            return status
            
        except Exception as e:
            logger.error(f"收集状态失败: {e}")
            return {
                'node_id': self.config['node_id'],
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'status': 'error',
                'error': str(e)
            }
    
    def update_gui_status(self, **kwargs):
        """更新GUI状态（由GUI调用）"""
        with self._lock:
            self._status_cache.update(kwargs)
            logger.debug(f"GUI状态更新: {kwargs}")
    
    def _send_report(self, status: Dict[str, Any]) -> bool:
        """发送状态报告"""
        url = f"{self.config['monitor_url']}/api/ar/nodes/{self.config['node_id']}/heartbeat"
        
        for attempt in range(self.config['max_retries']):
            try:
                response = self.session.post(
                    url,
                    json=status,
                    timeout=self.config['timeout']
                )
                
                if response.status_code == 200:
                    logger.debug(f"状态上报成功: {response.json()}")
                    return True
                else:
                    logger.warning(f"状态上报失败: HTTP {response.status_code}")
                    
            except requests.exceptions.ConnectionError:
                logger.warning(f"连接失败 (尝试 {attempt + 1}/{self.config['max_retries']})")
            except requests.exceptions.Timeout:
                logger.warning(f"请求超时 (尝试 {attempt + 1}/{self.config['max_retries']})")
            except Exception as e:
                logger.error(f"上报异常: {e}")
                
            if attempt < self.config['max_retries'] - 1:
                time.sleep(self.config['retry_delay'])
                
        return False
    
    def _report_loop(self):
        """上报循环"""
        logger.info(f"状态上报线程启动，间隔: {self.config['report_interval']}秒")
        
        while self.running:
            try:
                status = self._collect_status()
                success = self._send_report(status)
                
                if success:
                    self.last_report_time = datetime.utcnow()
                    self.report_count += 1
                    logger.info(f"状态上报成功 [#{self.report_count}]")
                else:
                    self.error_count += 1
                    logger.error(f"状态上报失败 [#{self.error_count}]")
                    
            except Exception as e:
                logger.error(f"上报循环异常: {e}")
                
            # 等待下一次上报
            for _ in range(self.config['report_interval']):
                if not self.running:
                    break
                time.sleep(1)
                
        logger.info("状态上报线程停止")
    
    def start(self) -> bool:
        """启动状态上报"""
        if not self.config['enabled']:
            logger.info("状态上报已禁用")
            return False
            
        if self.running:
            logger.warning("状态上报已在运行")
            return False
            
        self.running = True
        self.thread = threading.Thread(target=self._report_loop, daemon=True)
        self.thread.start()
        
        logger.info(f"状态上报服务启动: {self.config['node_id']} -> {self.config['monitor_url']}")
        return True
    
    def stop(self):
        """停止状态上报"""
        if not self.running:
            return
            
        logger.info("正在停止状态上报服务...")
        self.running = False
        
        if self.thread:
            self.thread.join(timeout=5)
            
        logger.info("状态上报服务已停止")
    
    def get_stats(self) -> Dict[str, Any]:
        """获取上报统计"""
        return {
            'running': self.running,
            'report_count': self.report_count,
            'error_count': self.error_count,
            'last_report_time': self.last_report_time.isoformat() if self.last_report_time else None,
            'config': {
                'node_id': self.config['node_id'],
                'monitor_url': self.config['monitor_url'],
                'interval': self.config['report_interval']
            }
        }


# 全局实例
_status_reporter: Optional[StatusReporter] = None

def get_reporter() -> StatusReporter:
    """获取状态上报器实例（单例）"""
    global _status_reporter
    if _status_reporter is None:
        # 查找配置文件
        config_paths = [
            Path(__file__).parent.parent / 'config' / 'monitor_config.yaml',
            Path.cwd() / 'config' / 'monitor_config.yaml',
        ]
        
        config_path = None
        for path in config_paths:
            if path.exists():
                config_path = str(path)
                break
                
        _status_reporter = StatusReporter(config_path)
        
    return _status_reporter


if __name__ == '__main__':
    # 测试运行
    reporter = StatusReporter()
    reporter.start()
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        reporter.stop()
```

#### 文件2: user/services/monitor_client.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
YL-monitor 客户端
提供与监控平台的完整交互能力
"""

import os
import json
import logging
import requests
from typing import Dict, Any, Optional, List
from datetime import datetime

logger = logging.getLogger('MonitorClient')


class MonitorClient:
    """
    YL-monitor 客户端
    """
    
    def __init__(self, base_url: Optional[str] = None):
        self.base_url = base_url or os.getenv('YL_MONITOR_URL', 'http://localhost:5500')
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        })
        self.timeout = 5
        
    def health_check(self) -> Dict[str, Any]:
        """检查监控平台健康状态"""
        try:
            response = self.session.get(
                f'{self.base_url}/api/health',
                timeout=self.timeout
            )
            return response.json()
        except Exception as e:
            logger.error(f"健康检查失败: {e}")
            return {'status': 'unhealthy', 'error': str(e)}
    
    def register_node(self, node_id: str, node_name: str, node_type: str = 'frontend') -> bool:
        """注册节点到监控平台"""
        try:
            data = {
                'node_id': node_id,
                'node_name': node_name,
                'node_type': node_type,
                'register_time': datetime.utcnow().isoformat() + 'Z'
            }
            
            response = self.session.post(
                f'{self.base_url}/api/ar/nodes/register',
                json=data,
                timeout=self.timeout
            )
            
            return response.status_code == 200
            
        except Exception as e:
            logger.error(f"节点注册失败: {e}")
            return False
    
    def send_heartbeat(self, node_id: str, status: Dict[str, Any]) -> bool:
        """发送心跳"""
        try:
            response = self.session.post(
                f'{self.base_url}/api/ar/nodes/{node_id}/heartbeat',
                json=status,
                timeout=self.timeout
            )
            return response.status_code == 200
        except Exception as e:
            logger.error(f"心跳发送失败: {e}")
            return False
    
    def get_alerts(self) -> List[Dict[str, Any]]:
        """获取告警列表"""
        try:
            response = self.session.get(
                f'{self.base_url}/api/alerts',
                timeout=self.timeout
            )
            return response.json().get('alerts', [])
        except Exception as e:
            logger.error(f"获取告警失败: {e}")
            return []
    
    def acknowledge_alert(self, alert_id: str) -> bool:
        """确认告警"""
        try:
            response = self.session.post(
                f'{self.base_url}/api/alerts/{alert_id}/acknowledge',
                timeout=self.timeout
            )
            return response.status_code == 200
        except Exception as e:
            logger.error(f"确认告警失败: {e}")
            return False
```

#### 文件3: user/services/local_http_server.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
User GUI 本地HTTP服务
提供本地状态查询接口
"""

import json
import logging
from http.server import HTTPServer, BaseHTTPRequestHandler
from threading import Thread
from typing import Optional

logger = logging.getLogger('LocalHTTPServer')


class StatusHandler(BaseHTTPRequestHandler):
    """状态请求处理器"""
    
    status_reporter = None  # 由外部设置
    
    def log_message(self, format, *args):
        """自定义日志"""
        logger.info(f"{self.address_string()} - {format % args}")
    
    def do_GET(self):
        """处理GET请求"""
        if self.path == '/health':
            self._send_health()
        elif self.path == '/status':
            self._send_status()
        elif self.path == '/stats':
            self._send_stats()
        else:
            self._send_error(404, "Not Found")
    
    def _send_health(self):
        """发送健康状态"""
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        
        response = {
            'status': 'healthy',
            'service': 'user-gui',
            'version': '2.0.0',
            'timestamp': __import__('datetime').datetime.utcnow().isoformat() + 'Z'
        }
        
        self.wfile.write(json.dumps(response).encode())
    
    def _send_status(self):
        """发送详细状态"""
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        
        if self.status_reporter:
            status = self.status_reporter._collect_status()
        else:
            status = {'status': 'unknown', 'error': 'Status reporter not initialized'}
        
        self.wfile.write(json.dumps(status).encode())
    
    def _send_stats(self):
        """发送统计信息"""
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        
        if self.status_reporter:
            stats = self.status_reporter.get_stats()
        else:
            stats = {'error': 'Status reporter not initialized'}
        
        self.wfile.write(json.dumps(stats).encode())
    
    def _send_error(self, code: int, message: str):
        """发送错误响应"""
        self.send_response(code)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        
        response = {
            'error': message,
            'code': code
        }
        
        self.wfile.write(json.dumps(response).encode())


class LocalHTTPServer:
    """
    本地HTTP服务
    """
    
    def __init__(self, port: int = 5502, status_reporter=None):
        self.port = port
        self.status_reporter = status_reporter
        self.server: Optional[HTTPServer] = None
        self.thread: Optional[Thread] = None
        self.running = False
        
    def start(self) -> bool:
        """启动服务"""
        try:
            StatusHandler.status_reporter = self.status_reporter
            
            self.server = HTTPServer(('0.0.0.0', self.port), StatusHandler)
            self.thread = Thread(target=self.server.serve_forever, daemon=True)
            self.thread.start()
            self.running = True
            
            logger.info(f"本地HTTP服务启动: http://localhost:{self.port}")
            return True
            
        except Exception as e:
            logger.error(f"启动HTTP服务失败: {e}")
            return False
    
    def stop(self):
        """停止服务"""
        if self.server:
            self.server.shutdown()
            self.running = False
            logger.info("本地HTTP服务已停止")
```

#### 文件4: user/config/monitor_config.yaml

```yaml
# User GUI 监控配置

monitor:
  # YL-monitor 地址
  url: "http://localhost:5500"
  
  # 节点标识
  node_id: "user-gui"
  node_name: "User GUI Application"
  
  # 上报配置
  report_interval: 30  # 秒
  timeout: 5  # 秒
  max_retries: 3
  retry_delay: 2  # 秒
  
  # 功能开关
  enabled: true

# 本地HTTP服务配置
local_server:
  enabled: true
  port: 5502

# 日志配置
logging:
  level: "INFO"
  file: "logs/user_gui_monitor.log"
```

### 2.3 修改现有文件

#### 修改1: user/gui/gui.py

在 `ARApp` 类的 `__init__` 方法中添加状态上报初始化：

```python
class ARApp(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # ... 原有初始化代码 ...
        
        # 初始化状态上报
        self._init_status_reporter()
        
    def _init_status_reporter(self):
        """初始化状态上报"""
        try:
            from services.status_reporter import get_reporter
            from services.local_http_server import LocalHTTPServer
            
            # 获取状态上报器
            self.status_reporter = get_reporter()
            
            # 启动状态上报
            if self.status_reporter.start():
                self.log_message("状态上报服务已启动", "success")
            
            # 启动本地HTTP服务
            self.local_server = LocalHTTPServer(
                port=5502,
                status_reporter=self.status_reporter
            )
            if self.local_server.start():
                self.log_message("本地HTTP服务已启动 (端口: 5502)", "success")
                
        except Exception as e:
            self.log_message(f"状态上报初始化失败: {e}", "error")
    
    def update_monitor_status(self, **kwargs):
        """更新监控状态（在关键操作时调用）"""
        if hasattr(self, 'status_reporter') and self.status_reporter:
            self.status_reporter.update_gui_status(**kwargs)
    
    # 在关键操作中更新状态
    def start_camera(self):
        """启动摄像头"""
        # ... 原有代码 ...
        
        # 更新监控状态
        self.update_monitor_status(video_running=True)
    
    def stop_camera(self):
        """停止摄像头"""
        # ... 原有代码 ...
        
        # 更新监控状态
        self.update_monitor_status(video_running=False)
    
    def start_audio(self):
        """启动音频"""
        # ... 原有代码 ...
        
        # 更新监控状态
        self.update_monitor_status(audio_running=True)
    
    def stop_audio(self):
        """停止音频"""
        # ... 原有代码 ...
        
        # 更新监控状态
        self.update_monitor_status(audio_running=False)
    
    def select_image(self):
        """选择图片"""
        # ... 原有代码 ...
        
        # 更新监控状态
        self.update_monitor_status(face_loaded=True)
    
    def closeEvent(self, event):
        """窗口关闭事件"""
        # 停止状态上报
        if hasattr(self, 'status_reporter') and self.status_reporter:
            self.status_reporter.stop()
        
        if hasattr(self, 'local_server') and self.local_server:
            self.local_server.stop()
        
        self.stop_camera()
        self.stop_audio()
        event.accept()
```

#### 修改2: user/main.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
User GUI 启动入口
"""

import sys
import os
from pathlib import Path

# 设置项目路径
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))
sys.path.insert(0, str(project_root / 'AR-backend'))
sys.path.insert(0, str(project_root / 'AR-backend' / 'core'))

# 创建必要的目录
(Path(__file__).parent / 'logs').mkdir(exist_ok=True)
(Path(__file__).parent / 'config').mkdir(exist_ok=True)

from PyQt5.QtWidgets import QApplication
from gui.gui import ARApp


def main():
    """主函数"""
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    app.setApplicationName("AR Live Studio")
    app.setApplicationVersion("2.0.0")
    
    # 创建主窗口
    window = ARApp()
    window.show()
    
    # 运行应用
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
```

## 三、关联内容修复

### 3.1 需要同步修复的文件

| 文件 | 修复内容 | 原因 |
|------|----------|------|
| `user/gui/gui.py` | 添加状态上报初始化和更新调用 | 集成状态上报功能 |
| `user/main.py` | 完善启动入口，添加路径设置 | 确保模块正确导入 |
| `user/README.md` | 添加监控配置说明 | 文档同步 |
| `YL-monitor/app/services/ar_monitor.py` | 添加User GUI节点处理 | 接收状态上报 |

### 3.2 YL-monitor端修复

在 `YL-monitor/app/services/ar_monitor.py` 中添加User GUI节点处理：

```python
# 在节点处理逻辑中添加
SUPPORTED_NODE_TYPES = {
    'ar-backend': ARBackendNodeHandler,
    'user-gui': UserGUINodeHandler,  # 新增
}

class UserGUINodeHandler:
    """User GUI节点处理器"""
    
    @staticmethod
    def process_heartbeat(node_id: str, data: dict):
        """处理User GUI心跳"""
        return {
            'node_id': node_id,
            'status': data.get('status', 'unknown'),
            'gui_status': data.get('gui', {}),
            'resources': data.get('resources', {}),
            'last_update': data.get('timestamp')
        }
```

## 四、部署执行步骤

### 4.1 执行前检查

```bash
# 1. 确认任务1.1已完成（YL-monitor可访问）
curl http://localhost:5500/api/health

# 2. 检查Python依赖
pip list | grep -E "requests|pyyaml|psutil"

# 3. 检查端口
lsof -i :5502  # 本地HTTP服务端口
```

### 4.2 部署执行

```bash
# 1. 创建目录
mkdir -p user/services
mkdir -p user/config
mkdir -p user/logs

# 2. 创建服务文件（复制上述代码）
# user/services/status_reporter.py
# user/services/monitor_client.py
# user/services/local_http_server.py
# user/config/monitor_config.yaml

# 3. 安装依赖
pip install requests pyyaml psutil

# 4. 修改gui.py集成状态上报

# 5. 启动测试
cd user
python main.py
```

### 4.3 部署验证

```bash
# 1. 检查本地HTTP服务
curl http://localhost:5502/health
# 预期: {"status": "healthy", "service": "user-gui", ...}

# 2. 检查状态查询
curl http://localhost:5502/status

# 3. 检查统计信息
curl http://localhost:5502/stats

# 4. 在YL-monitor查看节点
curl http://localhost:5500/api/ar/nodes/user-gui

# 5. 检查日志
tail -f user/logs/user_gui_monitor.log
```

## 五、常见问题及解决

### 问题1: 上报失败连接拒绝

**现象:** 日志显示 "Connection refused"

**解决:**
```bash
# 确认YL-monitor已启动
curl http://localhost:5500/api/health

# 检查配置
cat user/config/monitor_config.yaml

# 或设置环境变量
export YL_MONITOR_URL=http://localhost:5500
```

### 问题2: 端口5502被占用

**现象:** "Address already in use"

**解决:**
```bash
# 查找占用进程
lsof -i :5502

# 修改配置使用其他端口
# 修改 user/config/monitor_config.yaml
local_server:
  port: 5503
```

### 问题3: 线程阻塞GUI

**现象:** GUI界面卡顿

**解决:**
```python
# 确保使用daemon线程
self.thread = threading.Thread(target=self._report_loop, daemon=True)

# 设置超时
response = self.session.post(url, json=status, timeout=5)
```

## 六、验证清单

- [x] 文件创建完成（status_reporter.py, monitor_client.py, local_http_server.py, monitor_config.yaml）
- [x] 依赖安装完成（requests, pyyaml, psutil）
- [x] gui.py已修改集成状态上报
- [x] main.py已完善
- [x] 本地HTTP服务启动成功（端口5502）
- [x] /health端点返回正确
- [x] 状态上报线程正常运行
- [x] YL-monitor能接收心跳
- [x] 日志记录正常
- [x] 无GUI卡顿现象

## 七、下一步

完成本任务后，继续执行 **任务1.3: YL-monitor 节点配置**

查看文档: `部署/任务跟踪-阶段1-监控整合-部署任务1.3-YL-monitor节点配置.md`
