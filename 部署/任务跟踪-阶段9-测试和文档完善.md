# 阶段8：测试和文档完善 - 详细任务跟踪文档

**阶段:** 8  
**名称:** 测试和文档完善  
**预计工期:** 2-3天  
**优先级:** P1（重要优先级）  
**前置依赖:** 阶段7生产环境准备完成  
**状态:** 待开始

---

## 一、阶段目标

完成全面的测试覆盖（单元测试、集成测试、端到端测试）和完善所有项目文档（用户文档、开发文档、运维文档）。

---

## 二、任务优先级矩阵

| 任务ID | 任务名称 | 优先级 | 关键性 | 风险等级 | 依赖任务 |
|--------|----------|--------|--------|----------|----------|
| 8.1 | 单元测试补充 | P1 | 重要 | 中 | 7.8 |
| 8.2 | 集成测试完善 | P1 | 重要 | 中 | 8.1 |
| 8.3 | 端到端测试 | P0 | 阻塞性 | 高 | 8.2 |
| 8.4 | 性能压力测试 | P1 | 重要 | 中 | 8.3 |
| 8.5 | 用户文档编写 | P1 | 重要 | 中 | 8.4 |
| 8.6 | 开发文档完善 | P2 | 一般 | 低 | 8.5 |
| 8.7 | 运维文档编写 | P1 | 重要 | 中 | 8.6 |
| 8.8 | 文档审查和发布 | P1 | 重要 | 低 | 8.5-8.7 |

---

## 三、详细任务清单

### 任务8.1: 单元测试补充

**优先级:** P1  
**关键性:** 重要  
**负责人:** 测试开发工程师  
**预计工时:** 6小时

#### 工作内容
1. AR-backend核心业务模块单元测试
2. User GUI组件单元测试
3. YL-monitor服务单元测试
4. 规则引擎单元测试
5. 测试覆盖率提升

#### 测试框架搭建

```python
# test/conftest.py - pytest配置
import pytest
import sys
from pathlib import Path

# 添加项目路径
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))
sys.path.insert(0, str(project_root / 'AR-backend'))
sys.path.insert(0, str(project_root / 'user'))

@pytest.fixture
def app():
    """创建测试应用实例"""
    from AR-backend.app import create_app
    app = create_app(testing=True)
    return app

@pytest.fixture
def client(app):
    """创建测试客户端"""
    return app.test_client()

@pytest.fixture
def runner(app):
    """创建CLI runner"""
    return app.test_cli_runner()
```

#### AR-backend单元测试

```python
# test/test_backend/test_video_processor.py
import pytest
import numpy as np
from unittest.mock import Mock, patch

class TestVideoProcessor:
    """视频处理器单元测试"""
    
    @pytest.fixture
    def processor(self):
        from AR-backend.app.core.video_processor import VideoProcessor
        return VideoProcessor()
    
    def test_initialization(self, processor):
        """测试初始化"""
        assert processor is not None
        assert hasattr(processor, 'supported_formats')
    
    def test_frame_processing(self, processor):
        """测试帧处理"""
        # 创建测试帧
        frame = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
        
        # 处理帧
        result = processor.process_frame(frame)
        
        assert result is not None
        assert result.shape == frame.shape
    
    def test_invalid_frame(self, processor):
        """测试无效帧处理"""
        with pytest.raises(ValueError):
            processor.process_frame(None)
    
    @patch('cv2.VideoCapture')
    def test_camera_capture(self, mock_capture, processor):
        """测试摄像头捕获"""
        mock_cap = Mock()
        mock_cap.isOpened.return_value = True
        mock_cap.read.return_value = (True, np.zeros((480, 640, 3)))
        mock_capture.return_value = mock_cap
        
        result = processor.capture_from_camera(0)
        assert result is not None

# test/test_backend/test_face_swap.py
class TestFaceSwap:
    """人脸合成单元测试"""
    
    def test_model_loading(self):
        """测试模型加载"""
        from AR-backend.app.core.face_swap import FaceSwapModel
        
        model = FaceSwapModel()
        assert model.is_loaded()
    
    def test_face_detection(self):
        """测试人脸检测"""
        import cv2
        import numpy as np
        
        # 创建带人脸的测试图像
        frame = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
        
        from AR-backend.app.core.face_detector import FaceDetector
        detector = FaceDetector()
        faces = detector.detect(frame)
        
        assert isinstance(faces, list)
    
    def test_swap_performance(self):
        """测试合成性能"""
        import time
        from AR-backend.app.core.face_swap import FaceSwapModel
        
        model = FaceSwapModel()
        frame = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
        
        start = time.time()
        result = model.swap(frame)
        duration = time.time() - start
        
        assert duration < 0.1  # 100ms内完成
```

#### User GUI单元测试

```python
# test/test_frontend/test_gui_components.py
import pytest
from PyQt5.QtWidgets import QApplication
from PyQt5.QtTest import QTest
from PyQt5.QtCore import Qt

# 创建QApplication实例
app = QApplication([])

class TestARApp:
    """GUI应用单元测试"""
    
    @pytest.fixture
    def window(self):
        from user.gui.gui import ARApp
        window = ARApp()
        return window
    
    def test_window_initialization(self, window):
        """测试窗口初始化"""
        assert window is not None
        assert window.windowTitle() == "AR Live Studio"
    
    def test_camera_selection(self, window):
        """测试摄像头选择"""
        # 模拟摄像头选择
        window.camera_combo.setCurrentIndex(0)
        assert window.camera_combo.currentIndex() == 0
    
    def test_parameter_adjustment(self, window):
        """测试参数调整"""
        # 测试亮度调整
        window.brightness_slider.setValue(120)
        assert window.brightness_slider.value() == 120
    
    def test_preview_toggle(self, window):
        """测试预览开关"""
        initial_state = window.preview_checkbox.isChecked()
        QTest.mouseClick(window.preview_checkbox, Qt.LeftButton)
        assert window.preview_checkbox.isChecked() != initial_state
```

#### YL-monitor单元测试

```python
# test/test_monitor/test_ar_monitor.py
import pytest
from unittest.mock import Mock, patch

class TestARMonitor:
    """AR监控器单元测试"""
    
    @pytest.fixture
    def monitor(self):
        from YL-monitor.app.services.ar_monitor import ARMonitor
        return ARMonitor()
    
    def test_node_registration(self, monitor):
        """测试节点注册"""
        monitor.register_node({
            'node_id': 'test-node',
            'host': 'localhost',
            'port': 5501
        })
        
        assert 'test-node' in monitor.nodes
    
    def test_health_check(self, monitor):
        """测试健康检查"""
        with patch('requests.get') as mock_get:
            mock_get.return_value = Mock(
                status_code=200,
                json=lambda: {'status': 'healthy'}
            )
            
            result = monitor.check_health('test-node')
            assert result is True
    
    def test_heartbeat_receiving(self, monitor):
        """测试心跳接收"""
        monitor.update_heartbeat('test-node')
        assert monitor.nodes['test-node'].last_heartbeat is not None
```

#### 测试执行

```bash
# 运行所有单元测试
cd /home/vboxuser/桌面/项目部署/项目1/yl-ar-dgn_clean
pytest test/ -v --tb=short

# 生成覆盖率报告
pytest test/ --cov=AR-backend/app --cov=user --cov=YL-monitor/app --cov-report=html --cov-report=term

# 运行特定模块测试
pytest test/test_backend/ -v
pytest test/test_frontend/ -v
pytest test/test_monitor/ -v
```

#### 预期结果
- [ ] 单元测试覆盖率≥80%
- [ ] 核心业务模块测试通过
- [ ] GUI组件测试通过
- [ ] 监控服务测试通过

#### 可能产生的问题及解决方案

| 问题 | 风险等级 | 产生原因 | 解决方式 | 预防方式 |
|------|----------|----------|----------|----------|
| GUI测试困难 | 中 | PyQt5测试复杂 | 1. 使用QtTest<br>2. 模拟对象<br>3. 分离逻辑 | 1. MVC架构<br>2. 依赖注入 |
| 覆盖率不达标 | 中 | 测试遗漏 | 1. 补充测试<br>2. 边界测试<br>3. 异常测试 | 1. 覆盖率监控<br>2. 测试评审 |
| 测试不稳定 | 中 | 异步或时序问题 | 1. 等待机制<br>2. 重试策略<br>3. 隔离测试 | 1. 测试稳定性<br>2. 独立环境 |

#### 执行检查点
- [ ] 单元测试框架搭建
- [ ] 核心业务测试完成
- [ ] GUI组件测试完成
- [ ] 覆盖率达标

---

### 任务8.2: 集成测试完善

**优先级:** P1  
**关键性:** 重要  
**负责人:** 测试开发工程师  
**预计工时:** 4小时

#### 工作内容
1. API接口集成测试
2. 服务间通信测试
3. 数据库集成测试
4. 缓存集成测试
5. 第三方服务集成测试

#### API集成测试

```python
# test/test_integration/test_api_integration.py
import pytest
import requests

class TestAPIIntegration:
    """API集成测试"""
    
    BASE_URL = "http://localhost:5501"
    
    def test_health_endpoint(self):
        """测试健康检查端点"""
        response = requests.get(f"{self.BASE_URL}/health")
        assert response.status_code == 200
        data = response.json()
        assert data['status'] == 'healthy'
    
    def test_status_endpoint(self):
        """测试状态端点"""
        response = requests.get(f"{self.BASE_URL}/status")
        assert response.status_code == 200
        data = response.json()
        assert 'camera' in data
        assert 'audio' in data
    
    def test_metrics_endpoint(self):
        """测试指标端点"""
        response = requests.get(f"{self.BASE_URL}/metrics")
        assert response.status_code == 200
        data = response.json()
        assert 'system' in data
    
    def test_camera_control(self):
        """测试摄像头控制"""
        # 启动摄像头
        response = requests.post(
            f"{self.BASE_URL}/api/camera/start"
        )
        assert response.status_code == 200
        
        # 停止摄像头
        response = requests.post(
            f"{self.BASE_URL}/api/camera/stop"
        )
        assert response.status_code == 200
    
    def test_error_handling(self):
        """测试错误处理"""
        response = requests.get(f"{self.BASE_URL}/nonexistent")
        assert response.status_code == 404
        data = response.json()
        assert 'error' in data
```

#### 服务间集成测试

```python
# test/test_integration/test_service_integration.py
import pytest
import time
from unittest.mock import patch

class TestServiceIntegration:
    """服务间集成测试"""
    
    def test_gui_to_backend_communication(self):
        """测试GUI到后端通信"""
        from user.services.monitor_client import MonitorClient
        from AR-backend.monitor_server import app
        
        client = MonitorClient(backend_url="http://localhost:5501")
        
        # 测试状态获取
        status = client.get_backend_status()
        assert status is not None
    
    def test_monitor_to_backend_polling(self):
        """测试监控到后端轮询"""
        from YL-monitor.app.services.ar_monitor import ARMonitor
        
        monitor = ARMonitor()
        
        # 注册测试节点
        monitor.register_node({
            'node_id': 'ar-backend',
            'host': 'localhost',
            'port': 5501
        })
        
        # 执行健康检查
        result = monitor.check_health('ar-backend')
        assert result in [True, False]  # 根据实际状态
    
    def test_heartbeat_flow(self):
        """测试心跳流程"""
        from user.services.monitor_client import MonitorClient
        from YL-monitor.app.services.ar_monitor import ARMonitor
        
        # 启动心跳
        client = MonitorClient()
        client.start_heartbeat()
        
        # 等待心跳发送
        time.sleep(2)
        
        # 验证心跳接收
        monitor = ARMonitor()
        # 检查心跳时间戳
```

#### 数据库集成测试

```python
# test/test_integration/test_database_integration.py
import pytest

class TestDatabaseIntegration:
    """数据库集成测试"""
    
    def test_connection(self):
        """测试数据库连接"""
        from sqlalchemy import create_engine
        from AR-backend.app.models import db
        
        engine = create_engine('postgresql://user:pass@localhost/test_db')
        connection = engine.connect()
        assert connection
        connection.close()
    
    def test_crud_operations(self):
        """测试CRUD操作"""
        from AR-backend.app.models.alert import Alert
        
        # 创建
        alert = Alert.create(
            title="Test Alert",
            severity="warning"
        )
        assert alert.id is not None
        
        # 读取
        fetched = Alert.get_by_id(alert.id)
        assert fetched.title == "Test Alert"
        
        # 更新
        alert.update(status="resolved")
        assert alert.status == "resolved"
        
        # 删除
        alert.delete()
        assert Alert.get_by_id(alert.id) is None
```

#### 测试执行

```bash
# 运行集成测试
pytest test/test_integration/ -v --tb=short

# 使用测试数据库
pytest test/test_integration/ --database=test_db

# 生成报告
pytest test/test_integration/ --html=reports/integration_test_report.html
```

#### 预期结果
- [ ] API接口测试通过
- [ ] 服务间通信测试通过
- [ ] 数据库集成测试通过
- [ ] 所有集成场景覆盖

#### 可能产生的问题及解决方案

| 问题 | 风险等级 | 产生原因 | 解决方式 | 预防方式 |
|------|----------|----------|----------|----------|
| 服务未启动 | 高 | 依赖服务未运行 | 1. 启动依赖<br>2. 使用mock<br>3. 重试机制 | 1. 测试环境准备<br>2. 依赖检查 |
| 数据不一致 | 中 | 测试数据冲突 | 1. 事务隔离<br>2. 数据清理<br>3. 独立数据库 | 1. 测试数据管理<br>2. 清理机制 |
| 网络超时 | 中 | 网络延迟或服务慢 | 1. 增加超时<br>2. 异步测试<br>3. 本地服务 | 1. 超时配置<br>2. 性能优化 |

#### 执行检查点
- [ ] API集成测试完成
- [ ] 服务间集成测试完成
- [ ] 数据库集成测试完成
- [ ] 测试报告生成

---

### 任务8.3: 端到端测试

**优先级:** P0  
**关键性:** 阻塞性  
**负责人:** 测试工程师  
**预计工时:** 6小时

#### 工作内容
1. 完整用户流程测试
2. GUI→后端→监控端到端测试
3. 故障场景端到端测试
4. 性能端到端测试
5. 兼容性测试

#### 端到端测试脚本

```python
# test/test_e2e/test_full_workflow.py
import pytest
import time
import requests
from selenium import webdriver
from selenium.webdriver.common.by import By

class TestFullWorkflow:
    """完整工作流程端到端测试"""
    
    @pytest.fixture(scope="class")
    def driver(self):
        """创建浏览器驱动"""
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")
        driver = webdriver.Chrome(options=options)
        yield driver
        driver.quit()
    
    def test_complete_video_workflow(self, driver):
        """测试完整视频工作流程"""
        # 1. 启动AR-backend
        # 2. 启动User GUI
        # 3. 执行视频合成
        # 4. 验证监控数据
        
        # 验证后端健康
        response = requests.get("http://localhost:5501/health")
        assert response.status_code == 200
        
        # 打开监控面板
        driver.get("http://localhost:5000")
        time.sleep(2)
        
        # 验证监控面板加载
        assert "AR Monitor" in driver.title
        
        # 检查节点状态
        status_element = driver.find_element(By.ID, "ar-backend-status")
        assert status_element.text in ["online", "offline"]
    
    def test_alert_notification_flow(self, driver):
        """测试告警通知流程"""
        # 模拟服务故障
        # 验证告警触发
        # 验证通知发送
        
        # 停止服务模拟故障
        # requests.post("http://localhost:5501/api/shutdown")
        
        # 等待告警触发
        time.sleep(5)
        
        # 验证告警面板
        driver.get("http://localhost:5000/alerts")
        time.sleep(2)
        
        # 检查告警列表
        alerts = driver.find_elements(By.CLASS_NAME, "alert-item")
        # assert len(alerts) > 0  # 根据实际状态
    
    def test_gui_backend_integration(self):
        """测试GUI和后端集成"""
        from user.services.monitor_client import MonitorClient
        
        client = MonitorClient()
        
        # 获取后端状态
        status = client.get_backend_status()
        assert status is not None
        
        # 发送控制命令
        result = client.send_command("get_camera_status")
        assert result is not None
```

#### 故障场景测试

```python
# test/test_e2e/test_failure_scenarios.py
import pytest
import time
import requests
from unittest.mock import patch

class TestFailureScenarios:
    """故障场景测试"""
    
    def test_backend_offline(self):
        """测试后端离线场景"""
        # 模拟后端离线
        with patch('requests.get') as mock_get:
            mock_get.side_effect = requests.exceptions.ConnectionError()
            
            from user.services.monitor_client import MonitorClient
            client = MonitorClient()
            
            # 验证优雅降级
            status = client.get_backend_status()
            assert status is None or status == "offline"
    
    def test_network_interruption(self):
        """测试网络中断"""
        # 模拟网络中断
        # 验证自动重连
        # 验证数据恢复
        
        pass
    
    def test_resource_exhaustion(self):
        """测试资源耗尽"""
        # 模拟CPU/内存耗尽
        # 验证告警触发
        # 验证服务降级
        
        pass
    
    def test_recovery_procedure(self):
        """测试恢复流程"""
        # 模拟故障后恢复
        # 验证自动恢复
        # 验证数据一致性
        
        pass
```

#### 性能端到端测试

```python
# test/test_e2e/test_performance.py
import pytest
import time
import statistics

class TestEndToEndPerformance:
    """端到端性能测试"""
    
    def test_video_pipeline_latency(self):
        """测试视频处理管道延迟"""
        latencies = []
        
        for _ in range(100):
            start = time.time()
            
            # 执行完整视频处理流程
            # 1. 捕获帧
            # 2. 人脸检测
            # 3. 人脸合成
            # 4. 输出
            
            end = time.time()
            latencies.append((end - start) * 1000)  # 转换为ms
        
        avg_latency = statistics.mean(latencies)
        p95_latency = statistics.quantiles(latencies, n=20)[18]  # 95th percentile
        
        assert avg_latency < 100  # 平均<100ms
        assert p95_latency < 200  # 95%<200ms
    
    def test_throughput(self):
        """测试吞吐量"""
        start = time.time()
        count = 0
        
        # 在10秒内处理尽可能多的帧
        while time.time() - start < 10:
            # 处理一帧
            count += 1
        
        fps = count / 10
        assert fps >= 30  # 至少30fps
    
    def test_memory_usage(self):
        """测试内存使用"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        
        # 记录初始内存
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        # 运行一段时间
        time.sleep(60)
        
        # 记录最终内存
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        memory_increase = final_memory - initial_memory
        
        assert memory_increase < 100  # 内存增长<100MB
        assert final_memory < 500  # 总内存<500MB
```

#### 兼容性测试

```bash
# test/test_e2e/test_compatibility.sh
#!/bin/bash

# 测试不同浏览器
echo "测试Chrome..."
google-chrome --headless --disable-gpu http://localhost:5000

echo "测试Firefox..."
firefox --headless http://localhost:5000

# 测试不同分辨率
echo "测试不同分辨率..."
for resolution in "1920x1080" "1366x768" "1280x720"; do
    echo "测试分辨率: $resolution"
    # 使用xvfb模拟
    xvfb-run --server-args="-screen 0, $resolutionx24" \
        python3 test/test_e2e/test_resolution.py --resolution $resolution
done

# 测试不同操作系统（如果在CI中）
echo "兼容性测试完成"
```

#### 测试执行

```bash
# 运行端到端测试
pytest test/test_e2e/ -v --tb=short

# 使用Selenium运行
pytest test/test_e2e/ --driver=chrome

# 生成报告
pytest test/test_e2e/ --html=reports/e2e_test_report.html --self-contained-html
```

#### 预期结果
- [ ] 完整用户流程测试通过
- [ ] 故障场景测试通过
- [ ] 性能指标达标
- [ ] 兼容性测试通过

#### 可能产生的问题及解决方案

| 问题 | 风险等级 | 产生原因 | 解决方式 | 预防方式 |
|------|----------|----------|----------|----------|
| 测试不稳定 | 高 | 时序或异步问题 | 1. 等待机制<br>2. 重试策略<br>3. 同步点 | 1. 稳定性测试<br>2. 隔离环境 |
| 环境依赖 | 高 | 需要完整环境 | 1. Docker环境<br>2. Mock服务<br>3. 测试数据 | 1. 环境即代码<br>2. 自动化搭建 |
| 执行时间长 | 中 | 流程复杂 | 1. 并行执行<br>2. 优化流程<br>3. 选择性测试 | 1. 测试分层<br>2. CI优化 |

#### 执行检查点
- [ ] 端到端测试框架搭建
- [ ] 完整流程测试完成
- [ ] 故障场景测试完成
- [ ] 性能测试达标

---

### 任务8.4: 性能压力测试

**优先级:** P1  
**关键性:** 重要  
**负责人:** 性能测试工程师  
**预计工时:** 4小时

#### 工作内容
1. 负载测试
2. 压力测试
3. 稳定性测试
4. 容量规划测试
5. 性能基准建立

#### 负载测试

```python
# test/test_performance/test_load.py
import pytest
import threading
import time
import requests
import statistics

class TestLoad:
    """负载测试"""
    
    def test_concurrent_users(self):
        """测试并发用户"""
        num_users = 100
        requests_per_user = 10
        
        results = []
        
        def user_session(user_id):
            for i in range(requests_per_user):
                start = time.time()
                try:
                    response = requests.get(
                        "http://localhost:5501/health",
                        timeout=5
                    )
                    success = response.status_code == 200
                except:
                    success = False
                end = time.time()
                
                results.append({
                    'user_id': user_id,
                    'request_id': i,
                    'success': success,
                    'latency': (end - start) * 1000
                })
        
        # 启动并发用户
        threads = []
        start_time = time.time()
        
        for i in range(num_users):
            t = threading.Thread(target=user_session, args=(i,))
            threads.append(t)
            t.start()
        
        # 等待所有用户完成
        for t in threads:
            t.join()
        
        total_time = time.time() - start_time
        
        # 分析结果
        success_rate = sum(1 for r in results if r['success']) / len(results)
        latencies = [r['latency'] for r in results if r['success']]
        
        print(f"成功率: {success_rate * 100}%")
        print(f"平均延迟: {statistics.mean(latencies):.2f}ms")
        print(f"总时间: {total_time:.2f}s")
        
        assert success_rate >= 0.95  # 95%成功率
        assert statistics.mean(latencies) < 500  # 平均延迟<500ms
```

#### 压力测试

```bash
# test/test_performance/test_stress.sh
#!/bin/bash

# 使用Apache Bench进行压力测试
echo "压力测试: 健康检查端点"
ab -n 10000 -c 100 http://localhost:5501/health

echo "压力测试: 状态端点"
ab -n 5000 -c 50 http://localhost:5501/status

# 使用Locust进行更复杂的压力测试
echo "启动Locust压力测试..."
locust -f test/test_performance/locustfile.py --headless -u 1000 -r 100 --run-time 5m
```

```python
# test/test_performance/locustfile.py
from locust import HttpUser, task, between

class ARStudioUser(HttpUser):
    wait_time = between(1, 5)
    
    @task(10)
    def check_health(self):
        self.client.get("/health")
    
    @task(5)
    def get_status(self):
        self.client.get("/status")
    
    @task(3)
    def get_metrics(self):
        self.client.get("/metrics")
    
    @task(1)
    def control_camera(self):
        self.client.post("/api/camera/start")
        self.client.post("/api/camera/stop")
```

#### 稳定性测试

```python
# test/test_performance/test_stability.py
import pytest
import time
import psutil
import os

class TestStability:
    """稳定性测试"""
    
    def test_24_hour_stability(self):
        """测试24小时稳定性"""
        duration = 24 * 60 * 60  # 24小时
        interval = 60  # 每分钟检查
        
        start_time = time.time()
        errors = []
        
        while time.time() - start_time < duration:
            try:
                # 检查服务健康
                import requests
                response = requests.get(
                    "http://localhost:5501/health",
                    timeout=5
                )
                
                if response.status_code != 200:
                    errors.append({
                        'time': time.time(),
                        'error': f"HTTP {response.status_code}"
                    })
                
                # 检查资源使用
                process = psutil.Process(os.getpid())
                memory_mb = process.memory_info().rss / 1024 / 1024
                cpu_percent = process.cpu_percent()
                
                if memory_mb > 1000:  # 1GB
                    errors.append({
                        'time': time.time(),
                        'error': f"High memory usage: {memory_mb}MB"
                    })
                
                if cpu_percent > 90:
                    errors.append({
                        'time': time.time(),
                        'error': f"High CPU usage: {cpu_percent}%"
                    })
                
            except Exception as e:
                errors.append({
                    'time': time.time(),
                    'error': str(e)
                })
            
            time.sleep(interval)
        
        # 分析结果
        error_rate = len(errors) / (duration / interval)
        
        print(f"总检查次数: {duration / interval}")
        print(f"错误次数: {len(errors)}")
        print(f"错误率: {error_rate * 100}%")
        
        assert error_rate < 0.01  # 错误率<1%
```

#### 性能基准

```python
# test/test_performance/benchmark.py
import json
import time
from datetime import datetime

class PerformanceBenchmark:
    """性能基准测试"""
    
    def run_all_benchmarks(self):
        """运行所有基准测试"""
        results = {
            'timestamp': datetime.now().isoformat(),
            'tests': {}
        }
        
        # 视频处理基准
        results['tests']['video_processing'] = self.benchmark_video_processing()
        
        # 人脸合成基准
        results['tests']['face_swap'] = self.benchmark_face_swap()
        
        # 音频处理基准
        results['tests']['audio_processing'] = self.benchmark_audio_processing()
        
        # API响应基准
        results['tests']['api_response'] = self.benchmark_api_response()
        
        # 保存结果
        with open('reports/performance_benchmark.json', 'w') as f:
            json.dump(results, f, indent=2)
        
        return results
    
    def benchmark_video_processing(self):
        """视频处理基准"""
        import cv2
        import numpy as np
        
        frame = np.random.randint(0, 255, (1080, 1920, 3), dtype=np.uint8)
        
        times = []
        for _ in range(100):
            start = time.time()
            # 模拟处理
            processed = cv2.GaussianBlur(frame, (5, 5), 0)
            end = time.time()
            times.append((end - start) * 1000)
        
        import statistics
        return {
            'avg_ms': statistics.mean(times),
            'min_ms': min(times),
            'max_ms': max(times),
            'p95_ms': statistics.quantiles(times, n=20)[18]
        }
    
    def benchmark_face_swap(self):
        """人脸合成基准"""
        # 类似实现...
        pass
    
    def benchmark_audio_processing(self):
        """音频处理基准"""
        # 类似实现...
        pass
    
    def benchmark_api_response(self):
        """API响应基准"""
        import requests
        import statistics
        
        times = []
        for _ in range(100):
            start = time.time()
            requests.get("http://localhost:5501/health")
            end = time.time()
            times.append((end - start) * 1000)
        
        return {
            'avg_ms': statistics.mean(times),
            'min_ms': min(times),
            'max_ms': max(times),
            'p95_ms': statistics.quantiles(times, n=20)[18]
        }
```

#### 预期结果
- [ ] 负载测试通过 (100并发用户)
- [ ] 压力测试通过 (10000请求)
- [ ] 稳定性测试通过 (24小时无故障)
- [ ] 性能基准建立

#### 可能产生的问题及解决方案

| 问题 | 风险等级 | 产生原因 | 解决方式 | 预防方式 |
|------|----------|----------|----------|----------|
| 服务崩溃 | 高 | 负载过高 | 1. 限流<br>2. 扩容<br>3. 降级 | 1. 容量规划<br>2. 监控告警 |
| 内存泄漏 | 高 | 资源未释放 | 1. 代码修复<br>2. 定期重启<br>3. 资源监控 | 1. 内存检测<br>2. 自动化测试 |
| 性能不达标 | 中 | 算法或配置问题 | 1. 优化算法<br>2. 调整配置<br>3. 硬件升级 | 1. 性能基准<br>2. 持续优化 |

#### 执行检查点
- [ ] 负载测试完成
- [ ] 压力测试完成
- [ ] 稳定性测试完成
- [ ] 性能基准建立

---

### 任务8.5: 用户文档编写

**优先级:** P1  
**关键性:** 重要  
**负责人:** 技术文档工程师  
**预计工时:** 6小时

#### 工作内容
1. 安装指南编写
2. 使用手册编写
3. 故障排查指南
4. 快速入门教程
5. 视频教程制作（可选）

#### 安装指南

```markdown
# docs/user/INSTALL.md
# AR Live Studio 安装指南

## 系统要求

### 硬件要求
- **CPU**: Intel i5 或同等性能以上
- **内存**: 8GB RAM 以上
- **显卡**: 支持CUDA的NVIDIA显卡（推荐）
- **存储**: 20GB 可用空间
- **摄像头**: USB摄像头或内置摄像头

### 软件要求
- **操作系统**: Ubuntu 20.04+ / Windows 10+ / macOS 11+
- **Python**: 3.8 或更高版本
- **Docker**: 20.10+（可选，用于容器化部署）

## 安装步骤

### 1. 克隆项目
```bash
git clone https://github.com/your-org/yl-ar-dgn.git
cd yl-ar-dgn
```

### 2. 安装依赖
```bash
# 安装系统依赖（Ubuntu）
sudo apt-get update
sudo apt-get install -y python3-pip python3-venv \
    libgl1-mesa-glx libglib2.0-0 libsm6 libxext6 \
    libxrender-dev libgomp1

# 创建虚拟环境
python3 -m venv venv
source venv/bin/activate

# 安装Python依赖
pip install -r requirements.txt
```

### 3. 配置环境
```bash
# 复制环境配置模板
cp config/production.env.example config/production.env

# 编辑配置
nano config/production.env
```

### 4. 启动服务
```bash
# 启动AR-backend
cd AR-backend && ./start_monitor.sh

# 启动User GUI
cd user && python3 main.py
```

## 验证安装

访问 http://localhost:5501/health 检查服务状态。

## 常见问题

### Q: 摄像头无法打开
A: 检查摄像头权限：`ls -l /dev/video*`，确保当前用户有访问权限。

### Q: 模型加载失败
A: 检查模型文件是否存在：`ls AR-backend/models/`，必要时重新下载。
```

#### 使用手册

```markdown
# docs/user/MANUAL.md
# AR Live Studio 使用手册

## 界面概览

[界面截图]

### 主界面组件
1. **视频预览区** - 显示实时视频和合成效果
2. **控制面板** - 调整合成参数
3. **效果选择** - 选择人脸合成模型
4. **状态栏** - 显示系统状态和性能指标

## 基本操作

### 1. 启动视频合成
1. 选择视频源（摄像头/文件/网络流）
2. 选择目标人脸图片
3. 调整合成参数
4. 点击"开始合成"

### 2. 调整效果
- **亮度**: 调整视频亮度 (0.5-2.0)
- **对比度**: 调整对比度 (0.5-2.0)
- **饱和度**: 调整饱和度 (0.0-2.0)
- **平滑度**: 调整合成边缘平滑度

### 3. 音频处理
1. 选择音频源
2. 选择音效（音高/混响/变速）
3. 调整效果强度
4. 实时预览效果

### 4. 输出控制
- **虚拟摄像头**: 输出到虚拟摄像头设备
- **文件录制**: 录制到文件
- **网络推流**: 推送到RTMP服务器

## 高级功能

### 批量处理
```bash
python3 scripts/batch_process.py --input-dir ./input --output-dir ./output
```

### API调用
```python
import requests

# 获取状态
response = requests.get('http://localhost:5501/status')
