# Phase 5 - Task 5.3: Fault Simulation Testing - Detailed Deployment Document

**Task ID:** 5.3  
**Task Name:** Fault Simulation Testing  
**Priority:** P1 (High)  
**Estimated Hours:** 3 hours  
**Status:** Pending  
**Prerequisites:** Task 5.2 completed

---

## I. Task Objectives

Simulate various failure scenarios to test system resilience and recovery mechanisms.

## II. Fault Scenarios

### 2.1 Test Scenarios

| Fault Type | Component | Simulation Method | Expected Behavior |
|------------|-----------|-------------------|-------------------|
| Service crash | AR-backend | Kill process | Monitor detects, alerts |
| Network partition | User GUI | Block port | Timeout, retry, alert |
| High load | YL-monitor | CPU stress | Throttling, alerts |
| Memory exhaustion | Any | Memory allocation | Graceful degradation |
| Disk full | Any | Temp files | Cleanup, alert |

## III. Deployment Content

### 3.1 Fault Simulator

#### File: test/integration/fault_simulator.py

```python
#!/usr/bin/env python3
"""
Fault Simulator
Simulates various failure scenarios for testing
"""

import os
import sys
import time
import signal
import random
import subprocess
import requests
import psutil
from pathlib import Path
from typing import Dict, List, Callable


class FaultSimulator:
    """
    Fault Simulator
    """

    def __init__(self):
        self.results = []
        self.original_states = {}

    def simulate_service_crash(self, service_name: str, pid: int = None) -> Dict:
        """
        Simulate service crash by killing process
        """
        print(f"Simulating crash: {service_name}")

        if pid is None:
            # Find PID by service name
            pid = self._find_pid(service_name)

        if pid:
            try:
                os.kill(pid, signal.SIGTERM)
                time.sleep(1)

                # Check if process is gone
                try:
                    os.kill(pid, 0)
                    return {
                        'fault': 'service_crash',
                        'target': service_name,
                        'success': False,
                        'message': 'Process still running'
                    }
                except OSError:
                    return {
                        'fault': 'service_crash',
                        'target': service_name,
                        'success': True,
                        'message': 'Process terminated'
                    }
            except Exception as e:
                return {
                    'fault': 'service_crash',
                    'target': service_name,
                    'success': False,
                    'message': str(e)
                }
        else:
            return {
                'fault': 'service_crash',
                'target': service_name,
                'success': False,
                'message': 'PID not found'
            }

    def simulate_network_partition(self, port: int, duration: int = 10) -> Dict:
        """
        Simulate network partition by blocking port
        """
        print(f"Simulating network partition on port {port}")

        try:
            # Use iptables to block port (requires root)
            subprocess.run(
                ['sudo', 'iptables', '-A', 'INPUT', '-p', 'tcp',
                 '--dport', str(port), '-j', 'DROP'],
                check=True
            )

            time.sleep(duration)

            # Restore
            subprocess.run(
                ['sudo', 'iptables', '-D', 'INPUT', '-p', 'tcp',
                 '--dport', str(port), '-j', 'DROP'],
                check=True
            )

            return {
                'fault': 'network_partition',
                'target': f'port:{port}',
                'success': True,
                'duration': duration
            }

        except Exception as e:
            return {
                'fault': 'network_partition',
                'target': f'port:{port}',
                'success': False,
                'message': str(e)
            }

    def simulate_high_cpu(self, duration: int = 10) -> Dict:
        """
        Simulate high CPU load
        """
        print(f"Simulating high CPU for {duration}s")

        start_time = time.time()
        processes = []

        try:
            # Spawn CPU-intensive processes
            for _ in range(os.cpu_count()):
                p = subprocess.Popen([
                    sys.executable, '-c',
                    'while True: pass'
                ])
                processes.append(p)

            time.sleep(duration)

            # Cleanup
            for p in processes:
                p.terminate()

            return {
                'fault': 'high_cpu',
                'success': True,
                'duration': time.time() - start_time
            }

        except Exception as e:
            for p in processes:
                p.terminate()
            return {
                'fault': 'high_cpu',
                'success': False,
                'message': str(e)
            }

    def simulate_memory_pressure(self, size_mb: int = 500) -> Dict:
        """
        Simulate memory pressure
        """
        print(f"Simulating memory pressure: {size_mb}MB")

        try:
            # Allocate memory
            data = []
            for i in range(size_mb):
                data.append(bytearray(1024 * 1024))  # 1MB chunks
                if i % 100 == 0:
                    print(f"  Allocated {i}MB")

            # Hold for a moment
            time.sleep(2)

            # Release
            data = None

            return {
                'fault': 'memory_pressure',
                'size_mb': size_mb,
                'success': True
            }

        except MemoryError:
            return {
                'fault': 'memory_pressure',
                'success': True,
                'message': 'MemoryError raised as expected'
            }
        except Exception as e:
            return {
                'fault': 'memory_pressure',
                'success': False,
                'message': str(e)
            }

    def simulate_slow_response(self, target_url: str, delay: int = 5) -> Dict:
        """
        Simulate slow API response
        """
        print(f"Simulating slow response: {target_url}")

        # This would require a proxy or middleware
        # For now, just document the approach
        return {
            'fault': 'slow_response',
            'target': target_url,
            'success': False,
            'message': 'Requires proxy setup'
        }

    def _find_pid(self, service_name: str) -> int:
        """Find PID by service name"""
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                cmdline = ' '.join(proc.info['cmdline'] or [])
                if service_name.lower() in cmdline.lower():
                    return proc.info['pid']
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        return None

    def run_all_simulations(self) -> List[Dict]:
        """
        Run all fault simulations
        """
        simulations = [
            ('Service Crash (YL-monitor)', lambda: self.simulate_service_crash('YL-monitor')),
            ('Service Crash (AR-backend)', lambda: self.simulate_service_crash('AR-backend')),
            ('High CPU', lambda: self.simulate_high_cpu(5)),
            ('Memory Pressure', lambda: self.simulate_memory_pressure(200)),
        ]

        results = []
        for name, sim_func in simulations:
            print(f"\n{'='*50}")
            print(f"Running: {name}")
            print('='*50)

            result = sim_func()
            results.append(result)

            print(f"Result: {result}")

        return results

    def generate_report(self, results: List[Dict]) -> str:
        """
        Generate simulation report
        """
        lines = []
        lines.append("# Fault Simulation Report")
        lines.append(f"**Date:** {time.strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")

        passed = sum(1 for r in results if r.get('success'))
        total = len(results)

        lines.append(f"**Summary:** {passed}/{total} simulations successful")
        lines.append("")

        for result in results:
            status = "✓" if result.get('success') else "✗"
            lines.append(f"{status} **{result['fault']}** - {result.get('target', 'N/A')}")
            if 'message' in result:
                lines.append(f"  - {result['message']}")

        return '\n'.join(lines)


def main():
    """Main function"""
    simulator = FaultSimulator()

    print("Fault Simulation Testing")
    print("=" * 50)

    # Check if running as root (required for some simulations)
    if os.geteuid() != 0:
        print("Warning: Some simulations require root privileges")
        print("Run with sudo for full functionality")

    # Run simulations
    results = simulator.run_all_simulations()

    # Generate report
    report = simulator.generate_report(results)
    print("\n" + "=" * 50)
    print(report)

    # Save report
    report_file = Path(__file__).parent / 'fault_simulation_report.md'
    with open(report_file, 'w') as f:
        f.write(report)

    print(f"\nReport saved to: {report_file}")


if __name__ == '__main__':
    main()
```

### 3.2 Fault Test Runner

#### File: test/integration/run_fault_tests.sh

```bash
#!/bin/bash
# Run Fault Simulation Tests

set -e

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
LOG_FILE="$PROJECT_ROOT/logs/fault_tests_$(date +%Y%m%d_%H%M%S).log"

mkdir -p "$(dirname "$LOG_FILE")"

echo "========================================"
echo "Fault Simulation Tests"
echo "Started: $(date)"
echo "========================================"

# Check prerequisites
echo ""
echo "Checking prerequisites..."

if ! command -v python3 &> /dev/null; then
    echo "  ✗ Python3 not found"
    exit 1
fi

if ! python3 -c "import psutil" 2>/dev/null; then
    echo "  Installing psutil..."
    pip3 install psutil
fi

# Check if services are running
echo ""
echo "Checking service status..."

for service in 5500 5501 5502; do
    if nc -z localhost $service 2>/dev/null; then
        echo "  ✓ Port $service is active"
    else
        echo "  ✗ Port $service is not active"
    fi
done

# Run fault simulations
echo ""
echo "Running fault simulations..."

cd "$PROJECT_ROOT"
if python3 test/integration/fault_simulator.py 2>&1 | tee -a "$LOG_FILE"; then
    echo ""
    echo "✓ Fault simulations completed"
else
    echo ""
    echo "⚠ Some simulations may have failed (check log)"
fi

# Generate summary
echo ""
echo "========================================"
echo "Fault Test Summary"
echo "========================================"
echo "Log file: $LOG_FILE"

if [ -f "$PROJECT_ROOT/test/integration/fault_simulation_report.md" ]; then
    echo "Report: test/integration/fault_simulation_report.md"
fi
```

## IV. Deployment Steps

```bash
# 1. Create fault simulator
# Edit test/integration/fault_simulator.py

# 2. Create test runner
# Edit test/integration/run_fault_tests.sh

# 3. Make executable
chmod +x test/integration/run_fault_tests.sh

# 4. Install dependency
pip3 install psutil

# 5. Run tests (may require sudo for some tests)
./test/integration/run_fault_tests.sh
```

## V. Verification Checklist

- [ ] Fault simulator created
- [ ] Service crash test works
- [ ] Network partition test works
- [ ] High CPU test works
- [ ] Memory pressure test works
- [ ] Report generated

## VI. Next Step

After completing this task, proceed to **Task 5.4: Script Integration Testing**

View document: `部署/任务跟踪-阶段5-联调测试-部署任务5.4-脚本联调测试.md`
