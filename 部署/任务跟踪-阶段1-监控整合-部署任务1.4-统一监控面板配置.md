# 阶段1 - 任务1.4: 统一监控面板配置 - 详细部署文档

**任务ID:** 1.4  
**任务名称:** 统一监控面板配置  
**优先级:** P1（重要）  
**预计工时:** 4小时  
**状态:** 待执行  
**前置依赖:** 任务1.3完成（YL-monitor节点配置已完成）

---

## 一、任务目标

创建统一的监控面板界面，整合显示AR-backend和User GUI的状态信息，提供实时WebSocket更新。

## 二、部署内容

### 2.1 创建/修改文件清单

| 序号 | 文件路径 | 操作类型 | 说明 |
|------|----------|----------|------|
| 1 | `YL-monitor/templates/ar_dashboard.html` | 新建 | AR监控面板主页面 |
| 2 | `YL-monitor/static/js/ar_monitor.js` | 新建 | 前端监控逻辑 |
| 3 | `YL-monitor/static/css/ar_dashboard.css` | 新建 | 面板样式 |
| 4 | `YL-monitor/app/websocket/ar_ws.py` | 新建 | WebSocket处理 |
| 5 | `YL-monitor/app/routes/ar.py` | 修改 | 添加页面路由 |
| 6 | `YL-monitor/app/main.py` | 修改 | 注册WebSocket |

### 2.2 详细代码实现

#### 文件1: YL-monitor/templates/ar_dashboard.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR 系统监控面板</title>
    <link rel="stylesheet" href="/static/css/ar_dashboard.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="dashboard-container">
        <!-- 头部 -->
        <header class="dashboard-header">
            <h1><i class="fas fa-cube"></i> AR 系统监控面板</h1>
            <div class="header-stats">
                <span class="stat-item">
                    <i class="fas fa-server"></i>
                    总节点: <strong id="total-nodes">0</strong>
                </span>
                <span class="stat-item online">
                    <i class="fas fa-check-circle"></i>
                    在线: <strong id="online-nodes">0</strong>
                </span>
                <span class="stat-item offline">
                    <i class="fas fa-exclamation-circle"></i>
                    离线: <strong id="offline-nodes">0</strong>
                </span>
                <span class="connection-status" id="connection-status">
                    <i class="fas fa-plug"></i> 连接中...
                </span>
            </div>
        </header>

        <!-- 主内容区 -->
        <main class="dashboard-main">
            <!-- 节点状态卡片 -->
            <div class="nodes-grid" id="nodes-container">
                <!-- 节点卡片将动态插入这里 -->
            </div>

            <!-- 系统日志 -->
            <div class="logs-section">
                <h2><i class="fas fa-terminal"></i> 系统日志</h2>
                <div class="logs-container" id="logs-container">
                    <div class="log-entry info">
                        <span class="log-time">--:--:--</span>
                        <span class="log-level">INFO</span>
                        <span class="log-message">监控面板已启动</span>
                    </div>
                </div>
            </div>
        </main>

        <!-- 告警面板 -->
        <aside class="alerts-panel" id="alerts-panel">
            <h2><i class="fas fa-bell"></i> 告警</h2>
            <div class="alerts-list" id="alerts-list">
                <div class="alert-item info">
                    <i class="fas fa-info-circle"></i>
                    <span>暂无告警</span>
                </div>
            </div>
        </aside>
    </div>

    <!-- 节点详情模态框 -->
    <div class="modal" id="node-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">节点详情</h2>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- 详情内容 -->
            </div>
        </div>
    </div>

    <script src="/static/js/ar_monitor.js"></script>
</body>
</html>
```

#### 文件2: YL-monitor/static/js/ar_monitor.js

```javascript
/**
 * AR 监控面板前端逻辑
 * 提供WebSocket连接、实时更新、节点管理等功能
 */

class ARMonitorDashboard {
    constructor() {
        this.ws = null;
        this.reconnectInterval = 3000;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.nodes = new Map();
        this.logs = [];
        this.maxLogs = 100;
        
        this.init();
    }
    
    init() {
        this.connectWebSocket();
        this.setupEventListeners();
        this.startPeriodicUpdate();
    }
    
    connectWebSocket() {
        const wsUrl = `ws://${window.location.host}/ws/ar`;
        
        try {
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                console.log('WebSocket连接已建立');
                this.updateConnectionStatus('connected');
                this.reconnectAttempts = 0;
                this.addLog('WebSocket连接已建立', 'success');
            };
            
            this.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            };
            
            this.ws.onclose = () => {
                console.log('WebSocket连接已关闭');
                this.updateConnectionStatus('disconnected');
                this.addLog('WebSocket连接已关闭', 'warning');
                this.attemptReconnect();
            };
            
            this.ws.onerror = (error) => {
                console.error('WebSocket错误:', error);
                this.updateConnectionStatus('error');
                this.addLog('WebSocket连接错误', 'error');
            };
            
        } catch (error) {
            console.error('WebSocket连接失败:', error);
            this.attemptReconnect();
        }
    }
    
    attemptReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            this.addLog('达到最大重连次数，切换到轮询模式', 'warning');
            this.switchToPolling();
            return;
        }
        
        this.reconnectAttempts++;
        this.addLog(`尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`, 'info');
        
        setTimeout(() => {
            this.connectWebSocket();
        }, this.reconnectInterval);
    }
    
    switchToPolling() {
        // 降级到HTTP轮询
        this.pollingInterval = setInterval(() => {
            this.fetchNodesData();
        }, 5000);
        this.addLog('已切换到HTTP轮询模式', 'info');
    }
    
    handleMessage(data) {
        switch (data.type) {
            case 'nodes_update':
                this.updateNodes(data.nodes);
                break;
            case 'node_heartbeat':
                this.updateNodeHeartbeat(data.node_id, data.data);
                break;
            case 'alert':
                this.addAlert(data.alert);
                break;
            case 'log':
                this.addLog(data.message, data.level);
                break;
        }
    }
    
    updateNodes(nodesData) {
        this.nodes.clear();
        nodesData.forEach(node => {
            this.nodes.set(node.node_id, node);
        });
        this.renderNodes();
        this.updateStats();
    }
    
    renderNodes() {
        const container = document.getElementById('nodes-container');
        container.innerHTML = '';
        
        this.nodes.forEach((node, nodeId) => {
            const card = this.createNodeCard(node);
            container.appendChild(card);
        });
    }
    
    createNodeCard(node) {
        const card = document.createElement('div');
        card.className = `node-card ${node.is_online ? 'online' : 'offline'}`;
        card.onclick = () => this.showNodeDetails(node);
        
        const statusIcon = node.is_online ? 'fa-check-circle' : 'fa-exclamation-circle';
        const statusText = node.is_online ? '在线' : '离线';
        
        card.innerHTML = `
            <div class="node-header">
                <i class="fas ${node.node_type === 'ar-backend' ? 'fa-server' : 'fa-desktop'}"></i>
                <span class="node-name">${node.node_name}</span>
                <span class="node-status ${node.is_online ? 'online' : 'offline'}">
                    <i class="fas ${statusIcon}"></i> ${statusText}
                </span>
            </div>
            <div class="node-body">
                <div class="node-info">
                    <span>ID: ${node.node_id}</span>
                    <span>类型: ${node.node_type}</span>
                </div>
                ${this.renderNodeMetrics(node)}
            </div>
            <div class="node-footer">
                <span>最后更新: ${this.formatTime(node.last_heartbeat)}</span>
            </div>
        `;
        
        return card;
    }
    
    renderNodeMetrics(node) {
        if (!node.metadata || !node.metadata.resources) {
            return '<div class="metrics">暂无指标数据</div>';
        }
        
        const resources = node.metadata.resources;
        return `
            <div class="metrics">
                <div class="metric">
                    <i class="fas fa-microchip"></i>
                    <span>CPU: ${resources.cpu_percent || 0}%</span>
                </div>
                <div class="metric">
                    <i class="fas fa-memory"></i>
                    <span>内存: ${(resources.memory_mb || 0).toFixed(1)} MB</span>
                </div>
            </div>
        `;
    }
    
    updateStats() {
        const total = this.nodes.size;
        const online = Array.from(this.nodes.values()).filter(n => n.is_online).length;
        const offline = total - online;
        
        document.getElementById('total-nodes').textContent = total;
        document.getElementById('online-nodes').textContent = online;
        document.getElementById('offline-nodes').textContent = offline;
    }
    
    updateConnectionStatus(status) {
        const element = document.getElementById('connection-status');
        const icons = {
            connected: 'fa-plug',
            disconnected: 'fa-unplug',
            error: 'fa-exclamation-triangle'
        };
        const texts = {
            connected: '已连接',
            disconnected: '已断开',
            error: '连接错误'
        };
        const classes = {
            connected: 'connected',
            disconnected: 'disconnected',
            error: 'error'
        };
        
        element.className = `connection-status ${classes[status]}`;
        element.innerHTML = `<i class="fas ${icons[status]}"></i> ${texts[status]}`;
    }
    
    addLog(message, level = 'info') {
        const container = document.getElementById('logs-container');
        const entry = document.createElement('div');
        entry.className = `log-entry ${level}`;
        
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `
            <span class="log-time">${time}</span>
            <span class="log-level">${level.toUpperCase()}</span>
            <span class="log-message">${message}</span>
        `;
        
        container.appendChild(entry);
        container.scrollTop = container.scrollHeight;
        
        // 限制日志数量
        while (container.children.length > this.maxLogs) {
            container.removeChild(container.firstChild);
        }
    }
    
    addAlert(alert) {
        const container = document.getElementById('alerts-list');
        const item = document.createElement('div');
        item.className = `alert-item ${alert.level}`;
        item.innerHTML = `
            <i class="fas ${alert.level === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'}"></i>
            <span>${alert.message}</span>
            <small>${this.formatTime(alert.timestamp)}</small>
        `;
        
        container.insertBefore(item, container.firstChild);
        
        // 限制告警数量
        while (container.children.length > 20) {
            container.removeChild(container.lastChild);
        }
    }
    
    showNodeDetails(node) {
        const modal = document.getElementById('node-modal');
        const title = document.getElementById('modal-title');
        const body = document.getElementById('modal-body');
        
        title.textContent = `${node.node_name} - 详细信息`;
        body.innerHTML = `
            <div class="detail-section">
                <h3>基本信息</h3>
                <table class="detail-table">
                    <tr><td>节点ID</td><td>${node.node_id}</td></tr>
                    <tr><td>节点名称</td><td>${node.node_name}</td></tr>
                    <tr><td>节点类型</td><td>${node.node_type}</td></tr>
                    <tr><td>状态</td><td>${node.status}</td></tr>
                    <tr><td>在线状态</td><td>${node.is_online ? '在线' : '离线'}</td></tr>
                </table>
            </div>
            <div class="detail-section">
                <h3>时间信息</h3>
                <table class="detail-table">
                    <tr><td>最后检查</td><td>${this.formatTime(node.last_check)}</td></tr>
                    <tr><td>最后心跳</td><td>${this.formatTime(node.last_heartbeat)}</td></tr>
                </table>
            </div>
            <div class="detail-section">
                <h3>元数据</h3>
                <pre>${JSON.stringify(node.metadata, null, 2)}</pre>
            </div>
        `;
        
        modal.style.display = 'block';
    }
    
    formatTime(isoTime) {
        if (!isoTime) return '从未';
        const date = new Date(isoTime);
        return date.toLocaleString();
    }
    
    setupEventListeners() {
        // 模态框关闭
        window.onclick = (event) => {
            const modal = document.getElementById('node-modal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    }
    
    startPeriodicUpdate() {
        // 定期获取完整数据（作为WebSocket的备份）
        setInterval(() => {
            this.fetchNodesData();
        }, 30000);
    }
    
    async fetchNodesData() {
        try {
            const response = await fetch('/api/ar/nodes');
            const nodes = await response.json();
            this.updateNodes(nodes);
        } catch (error) {
            console.error('获取节点数据失败:', error);
        }
    }
}

// 全局函数
function closeModal() {
    document.getElementById('node-modal').style.display = 'none';
}

// 初始化
document.addEventListener('DOMContentLoaded', () => {
    window.dashboard = new ARMonitorDashboard();
});
```

#### 文件3: YL-monitor/static/css/ar_dashboard.css

```css
/* AR 监控面板样式 */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #f5f7fa;
    color: #333;
    line-height: 1.6;
}

.dashboard-container {
    display: grid;
    grid-template-areas:
        "header header"
        "main aside";
    grid-template-columns: 1fr 300px;
    grid-template-rows: auto 1fr;
    min-height: 100vh;
}

/* 头部 */
.dashboard-header {
    grid-area: header;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 1rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.dashboard-header h1 {
    font-size: 1.5rem;
    font-weight: 600;
}

.header-stats {
    display: flex;
    gap: 2rem;
    align-items: center;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
}

.stat-item.online { color: #4ade80; }
.stat-item.offline { color: #f87171; }

.connection-status {
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.connection-status.connected {
    background: rgba(74, 222, 128, 0.2);
    color: #4ade80;
}

.connection-status.disconnected {
    background: rgba(248, 113, 113, 0.2);
    color: #f87171;
}

/* 主内容区 */
.dashboard-main {
    grid-area: main;
    padding: 2rem;
    overflow-y: auto;
}

/* 节点网格 */
.nodes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.node-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: all 0.3s ease;
    border-left: 4px solid #e5e7eb;
}

.node-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
}

.node-card.online {
    border-left-color: #4ade80;
}

.node-card.offline {
    border-left-color: #f87171;
    opacity: 0.8;
}

.node-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1rem;
}

.node-name {
    font-weight: 600;
    flex: 1;
}

.node-status {
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 500;
}

.node-status.online {
    background: #dcfce7;
    color: #166534;
}

.node-status.offline {
    background: #fee2e2;
    color: #991b1b;
}

.node-info {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    color: #6b7280;
    font-size: 0.9rem;
    margin-bottom: 1rem;
}

.metrics {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

.metric {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: #f3f4f6;
    border-radius: 8px;
    font-size: 0.85rem;
}

.node-footer {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #e5e7eb;
    color: #9ca3af;
    font-size: 0.8rem;
}

/* 日志区域 */
.logs-section {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.logs-section h2 {
    font-size: 1.1rem;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.logs-container {
    max-height: 300px;
    overflow-y: auto;
    background: #1f2937;
    border-radius: 8px;
    padding: 1rem;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
}

.log-entry {
    display: flex;
    gap: 1rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid #374151;
    color: #e5e7eb;
}

.log-entry:last-child {
    border-bottom: none;
}

.log-time {
    color: #9ca3af;
    min-width: 80px;
}

.log-level {
    min-width: 60px;
    font-weight: 600;
}

.log-entry.success .log-level { color: #4ade80; }
.log-entry.warning .log-level { color: #fbbf24; }
.log-entry.error .log-level { color: #f87171; }
.log-entry.info .log-level { color: #60a5fa; }

/* 告警面板 */
.alerts-panel {
    grid-area: aside;
    background: white;
    padding: 1.5rem;
    border-left: 1px solid #e5e7eb;
    overflow-y: auto;
}

.alerts-panel h2 {
    font-size: 1.1rem;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.alerts-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.alert-item {
    padding: 1rem;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 0.9rem;
}

.alert-item.info {
    background: #dbeafe;
    color: #1e40af;
}

.alert-item.warning {
    background: #fef3c7;
    color: #92400e;
}

.alert-item.error {
    background: #fee2e2;
    color: #991b1b;
}

/* 模态框 */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
}

.modal-content {
    background: white;
    margin: 5% auto;
    padding: 2rem;
    border-radius: 12px;
    width: 80%;
    max-width: 700px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid #e5e7eb;
}

.close-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #6b7280;
}

.close-btn:hover {
    color: #374151;
}

.detail-section {
    margin-bottom: 1.5rem;
}

.detail-section h3 {
    font-size: 1rem;
    margin-bottom: 0.75rem;
    color: #4b5563;
}

.detail-table {
    width: 100%;
    border-collapse: collapse;
}

.detail-table td {
    padding: 0.5rem;
    border-bottom: 1px solid #e5e7eb;
}

.detail-table td:first-child {
    font-weight: 500;
    color: #6b7280;
    width: 30%;
}

/* 响应式 */
@media (max-width: 1024px) {
    .dashboard-container {
        grid-template-areas:
            "header"
            "main"
            "aside";
        grid-template-columns: 1fr;
    }
    
    .alerts-panel {
        border-left: none;
        border-top: 1px solid #e5e7eb;
    }
}
```

#### 文件4: YL-monitor/app/websocket/ar_ws.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AR 监控 WebSocket 处理
提供实时数据推送
"""

import json
import asyncio
import logging
from typing import Set
from fastapi import WebSocket, WebSocketDisconnect

logger = logging.getLogger('ARWebSocket')


class ARWebSocketManager:
    """
    AR监控WebSocket管理器
    """
    
    def __init__(self):
        self.active_connections: Set[WebSocket] = set()
        self.monitor = None
        
    async def connect(self, websocket: WebSocket):
        """接受WebSocket连接"""
        await websocket.accept()
        self.active_connections.add(websocket)
        logger.info(f"WebSocket客户端已连接，当前连接数: {len(self.active_connections)}")
        
        # 发送初始数据
        if self.monitor:
            nodes = [
                {
                    'node_id': n.node_id,
                    'node_name': n.node_name,
                    'node_type': n.node_type,
                    'status': n.status,
                    'is_online': n.is_online,
                    'last_check': n.last_check.isoformat() if n.last_check else None,
                    'last_heartbeat': n.last_heartbeat.isoformat() if n.last_heartbeat else None,
                    'metadata': n.metadata
                }
                for n in self.monitor.get_all_nodes()
            ]
            
            await websocket.send_json({
                'type': 'nodes_update',
                'nodes': nodes
            })
    
    def disconnect(self, websocket: WebSocket):
        """断开WebSocket连接"""
        self.active_connections.discard(websocket)
        logger.info(f"WebSocket客户端已断开，当前连接数: {len(self.active_connections)}")
    
    async def broadcast(self, message: dict):
        """广播消息到所有连接"""
        if not self.active_connections:
            return
            
        disconnected = set()
        
        for connection in self.active_connections:
            try:
                await connection.send_json(message)
            except Exception as e:
                logger.error(f"发送消息失败: {e}")
                disconnected.add(connection)
        
        # 清理断开的连接
        for conn in disconnected:
            self.active_connections.discard(conn)
    
    async def broadcast_nodes_update(self):
        """广播节点更新"""
        if not self.monitor or not self.active_connections:
            return
            
        nodes = [
            {
                'node_id': n.node_id,
                'node_name': n.node_name,
                'node_type': n.node_type,
                'status': n.status,
                'is_online': n.is_online,
                'last_check': n.last_check.isoformat() if n.last_check else None,
                'last_heartbeat': n.last_heartbeat.isoformat() if n.last_heartbeat else None,
                'metadata': n.metadata
            }
            for n in self.monitor.get_all_nodes()
        ]
        
        await self.broadcast({
            'type': 'nodes_update',
            'nodes': nodes
        })
    
    async def broadcast_heartbeat(self, node_id: str, data: dict):
        """广播心跳更新"""
        await self.broadcast({
            'type': 'node_heartbeat',
            'node_id': node_id,
            'data': data
        })
    
    async def broadcast_alert(self, alert: dict):
        """广播告警"""
        await self.broadcast({
            'type': 'alert',
            'alert': alert
        })
    
    async def broadcast_log(self, message: str, level: str = 'info'):
        """广播日志"""
        await self.broadcast({
            'type': 'log',
            'message': message,
            'level': level
        })


# 全局实例
ws_manager = ARWebSocketManager()


async def ar_websocket_endpoint(websocket: WebSocket):
    """
    AR监控WebSocket端点
    """
    await ws_manager.connect(websocket)
    
    try:
        while True:
            # 接收客户端消息（如ping）
            data = await websocket.receive_text()
            message = json.loads(data)
            
            if message.get('action') == 'ping':
                await websocket.send_json({'type': 'pong'})
                
    except WebSocketDisconnect:
        ws_manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"WebSocket错误: {e}")
        ws_manager.disconnect(websocket)
```

#### 文件5: 修改 YL-monitor/app/routes/ar.py

添加页面路由：

```python
from fastapi import Request
from fastapi.templating import Jinja2Templates
from pathlib import Path

# 模板配置
templates = Jinja2Templates(
    directory=str(Path(__file__).parent.parent / "templates")
)

# 添加页面路由
@router.get("/dashboard", response_class=HTMLResponse)
async def ar_dashboard(request: Request):
    """AR监控面板页面"""
    return templates.TemplateResponse(
        "ar_dashboard.html",
        {"request": request}
    )
```

#### 文件6: 修改 YL-monitor/app/main.py

注册WebSocket路由：

```python
from app.websocket.ar_ws import ar_websocket_endpoint, ws_manager

# 在应用初始化时设置监控器引用
@app.on_event("startup")
async def startup_event():
    # ... 其他初始化 ...
    
    # 设置WebSocket管理器的监控器引用
    if hasattr(app.state, 'ar_monitor') and app.state.ar_monitor:
        ws_manager.monitor = app.state.ar_monitor

# 注册WebSocket路由
app.add_websocket_route("/ws/ar", ar_websocket_endpoint)
```

## 三、关联内容修复

### 3.1 需要同步修复的文件

| 文件 | 修复内容 | 原因 |
|------|----------|------|
| `YL-monitor/app/main.py` | 注册WebSocket路由 | WebSocket集成 |
| `YL-monitor/app/routes/ar.py` | 添加页面路由 | 页面访问 |
| `YL-monitor/app/services/ar_monitor.py` | 集成WebSocket广播 | 实时更新 |

### 3.2 详细修复说明

#### 修复1: YL-monitor/app/services/ar_monitor.py

在状态更新时广播WebSocket消息：

```python
async def _check_node(self, node: NodeInfo):
    # ... 原有检查逻辑 ...
    
    # 广播更新
    from app.websocket.ar_ws import ws_manager
    await ws_manager.broadcast_nodes_update()
```

## 四、部署执行步骤

### 4.1 执行前检查

```bash
# 1. 确认任务1.3已完成
curl http://localhost:5500/api/ar/nodes

# 2. 检查模板目录
ls -la YL-monitor/templates/

# 3. 检查静态文件目录
ls -la YL-monitor/static/
```

### 4.2 部署执行

```bash
# 1. 创建文件
# YL-monitor/templates/ar_dashboard.html
# YL-monitor/static/js/ar_monitor.js
# YL-monitor/static/css/ar_dashboard.css
# YL-monitor/app/websocket/ar_ws.py

# 2. 修改路由文件
# YL-monitor/app/routes/ar.py

# 3. 修改主程序
# YL-monitor/app/main.py

# 4. 重启服务
cd YL-monitor
uvicorn app.main:app --reload --host 0.0.0.0 --port 5500
```

### 4.3 部署验证

```bash
# 1. 访问监控面板
open http://localhost:5500/api/ar/dashboard

# 2. 检查WebSocket连接
# 在浏览器开发者工具中查看WebSocket连接

# 3. 检查节点显示
# 确认AR-backend和User GUI节点显示正确

# 4. 测试实时更新
# 停止AR-backend服务，观察面板状态变化
```

## 五、常见问题及解决

### 问题1: WebSocket连接失败

**现象:** 面板显示"连接错误"

**解决:**
```javascript
// 检查WebSocket URL
const wsUrl = `ws://${window.location.host}/ws/ar`;

// 确认服务端路由已注册
app.add_websocket_route("/ws/ar", ar_websocket_endpoint);
```

### 问题2: 节点数据不显示

**现象:** 节点卡片为空

**解决:**
```bash
# 检查API返回
curl http://localhost:5500/api/ar/nodes

# 检查浏览器控制台错误
# 检查网络请求
```

### 问题3: 样式错乱

**现象:** 界面布局混乱

**解决:**
```bash
# 清除浏览器缓存
# 检查CSS文件加载
# 检查浏览器兼容性
```

## 六、验证清单

- [ ] HTML模板创建完成
- [ ] JS文件创建完成
- [ ] CSS文件创建完成
- [ ] WebSocket处理创建完成
- [ ] 路由修改完成
- [ ] 主程序修改完成
- [ ] 面板页面可访问
- [ ] WebSocket连接正常
- [ ] 节点数据实时更新
- [ ] 告警显示正常

## 七、下一步

完成本任务后，继续执行 **任务1.5: 告警规则配置**

查看文档: `部署/任务跟踪-阶段1-监控整合-部署任务1.5-告警规则配置.md`
