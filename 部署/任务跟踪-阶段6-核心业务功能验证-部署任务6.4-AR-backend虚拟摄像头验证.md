# 部署任务6.4: AR-backend虚拟摄像头验证

**任务ID:** 6.4  
**所属阶段:** 阶段6 - 核心业务功能验证  
**任务名称:** AR-backend虚拟摄像头验证  
**优先级:** P1（重要优先级）  
**关键性:** 重要  
**预计工时:** 3小时  
**负责人:** 系统工程师  
**前置依赖:** 任务6.1完成  
**状态:** 待开始

---

## 一、任务目标

验证AR-backend虚拟摄像头功能，确保v4l2loopback模块配置、虚拟摄像头设备创建、OBS集成和多应用访问功能正常。

---

## 二、工作内容

1. v4l2loopback模块配置
2. 虚拟摄像头设备创建
3. OBS集成测试
4. 多应用同时访问测试
5. 稳定性测试

---

## 三、实施步骤

### 步骤1: 检查v4l2loopback模块

```bash
# 1. 检查模块是否已加载
echo "检查v4l2loopback模块..."
lsmod | grep v4l2loopback || echo "模块未加载"

# 2. 检查模块信息
modinfo v4l2loopback 2>/dev/null || echo "模块信息不可用"

# 3. 检查内核版本
echo -e "\n内核版本:"
uname -r

# 4. 检查已安装的视频设备
echo -e "\n当前视频设备:"
ls -l /dev/video* 2>/dev/null || echo "无视频设备"
```

### 步骤2: 加载v4l2loopback模块

```bash
# 创建模块加载脚本
cat > /tmp/setup_v4l2loopback.sh << 'EOF'
#!/bin/bash
set -e

echo "========================================"
echo "v4l2loopback模块配置"
echo "========================================"

# 检查是否已加载
if lsmod | grep -q v4l2loopback; then
    echo "✓ v4l2loopback模块已加载"
else
    echo "加载v4l2loopback模块..."
    
    # 尝试加载模块
    if sudo modprobe v4l2loopback devices=1 video_nr=20 card_label="AR Virtual Cam" exclusive_caps=1 2>/dev/null; then
        echo "✓ 模块加载成功"
    else
        echo "✗ 模块加载失败"
        echo "尝试安装v4l2loopback..."
        
        # 尝试安装
        if command -v apt-get &> /dev/null; then
            sudo apt-get update
            sudo apt-get install -y v4l2loopback-dkms
            sudo modprobe v4l2loopback devices=1 video_nr=20 card_label="AR Virtual Cam" exclusive_caps=1
        else
            echo "✗ 无法自动安装，请手动安装v4l2loopback"
            exit 1
        fi
    fi
fi

# 验证设备创建
if [ -e "/dev/video20" ]; then
    echo "✓ 虚拟摄像头设备创建成功: /dev/video20"
    
    # 显示设备信息
    echo -e "\n设备信息:"
    v4l2-ctl --device=/dev/video20 --all 2>/dev/null || echo "v4l2-ctl不可用"
else
    echo "✗ 虚拟摄像头设备未创建"
    exit 1
fi

# 添加到开机加载
if ! grep -q "v4l2loopback" /etc/modules 2>/dev/null; then
    echo "添加到开机加载..."
    echo "v4l2loopback" | sudo tee -a /etc/modules
    echo "options v4l2loopback devices=1 video_nr=20 card_label='AR Virtual Cam' exclusive_caps=1" | sudo tee /etc/modprobe.d/v4l2loopback.conf
fi

echo "========================================"
echo "✓ v4l2loopback配置完成"
echo "========================================"
EOF

chmod +x /tmp/setup_v4l2loopback.sh
sudo /tmp/setup_v4l2loopback.sh
```

### 步骤3: 测试视频输出到虚拟摄像头

```bash
# 创建虚拟摄像头测试脚本
cat > /tmp/test_virtual_camera.py << 'EOF'
#!/usr/bin/env python3
import cv2
import sys
import time
import numpy as np

sys.path.insert(0, '/home/vboxuser/桌面/项目部署/项目1/yl-ar-dgn_clean/AR-backend')

def test_virtual_camera_output():
    print("=" * 50)
    print("虚拟摄像头输出测试")
    print("=" * 50)
    
    # 检查虚拟摄像头设备
    virtual_cam_path = "/dev/video20"
    
    if not os.path.exists(virtual_cam_path):
        print(f"✗ 虚拟摄像头设备不存在: {virtual_cam_path}")
        return False
    
    print(f"✓ 找到虚拟摄像头设备: {virtual_cam_path}")
    
    # 尝试打开虚拟摄像头作为输出
    try:
        # 使用OpenCV的VideoWriter
        fourcc = cv2.VideoWriter_fourcc(*'MJPG')
        out = cv2.VideoWriter(virtual_cam_path, fourcc, 30.0, (640, 480))
        
        if not out.isOpened():
            print("✗ 无法打开虚拟摄像头进行写入")
            return False
        
        print("✓ 虚拟摄像头已打开用于输出")
        
        # 生成测试视频流
        print("\n开始输出测试视频流 (5秒)...")
        
        test_duration = 5
        start_time = time.time()
        frame_count = 0
        
        while time.time() - start_time < test_duration:
            # 创建测试帧（彩色渐变）
            elapsed = time.time() - start_time
            r = int(128 + 127 * np.sin(elapsed * 2))
            g = int(128 + 127 * np.sin(elapsed * 2 + 2))
            b = int(128 + 127 * np.sin(elapsed * 2 + 4))
            
            frame = np.full((480, 640, 3), (b, g, r), dtype=np.uint8)
            
            # 添加时间戳
            cv2.putText(frame, f"Time: {elapsed:.2f}s", (10, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
            
            out.write(frame)
            frame_count += 1
            
            if frame_count % 30 == 0:
                print(f"  已输出 {frame_count} 帧")
            
            time.sleep(1/30)  # 30fps
        
        out.release()
        
        print(f"\n✓ 视频流输出完成")
        print(f"  总帧数: {frame_count}")
        print(f"  实际FPS: {frame_count / test_duration:.2f}")
        
        return True
        
    except Exception as e:
        print(f"✗ 虚拟摄像头输出错误: {e}")
        return False

if __name__ == "__main__":
    import os
    success = test_virtual_camera_output()
    sys.exit(0 if success else 1)
EOF

# 执行测试
python3 /tmp/test_virtual_camera.py
```

### 步骤4: OBS集成测试

```bash
# 创建OBS集成测试指南
cat > /tmp/test_obs_integration.md << 'EOF'
# OBS集成测试指南

## 测试步骤

### 1. 启动虚拟摄像头
确保AR-backend正在运行并输出到虚拟摄像头：
```bash
# 检查虚拟摄像头状态
ls -l /dev/video20
v4l2-ctl --device=/dev/video20 --all
```

### 2. 配置OBS
1. 打开OBS Studio
2. 在"来源"面板点击"+"
3. 选择"视频采集设备"
4. 在设备列表中选择"AR Virtual Cam"或"/dev/video20"
5. 点击"确定"

### 3. 验证视频流
- 在OBS预览窗口中应该能看到AR-backend输出的视频
- 检查视频是否流畅，无卡顿
- 验证分辨率和帧率是否正确

### 4. 测试录制和直播
- 点击"开始录制"测试本地录制
- 配置RTMP服务器进行直播测试
- 验证输出质量

## 预期结果
- [ ] OBS能识别虚拟摄像头
- [ ] 视频流显示正常
- [ ] 录制功能正常
- [ ] 直播功能正常（如配置）
EOF

echo "OBS集成测试指南已创建: /tmp/test_obs_integration.md"
echo "请按照指南手动测试OBS集成"
```

### 步骤5: 多应用访问测试

```bash
# 创建多应用访问测试脚本
cat > /tmp/test_multi_app_access.py << 'EOF'
#!/usr/bin/env python3
import cv2
import threading
import time
import sys

def read_from_virtual_cam(app_name, duration=10):
    """模拟应用程序读取虚拟摄像头"""
    print(f"[{app_name}] 开始读取虚拟摄像头...")
    
    cap = cv2.VideoCapture(20)  # /dev/video20
    
    if not cap.isOpened():
        print(f"[{app_name}] ✗ 无法打开虚拟摄像头")
        return False
    
    frame_count = 0
    start_time = time.time()
    
    while time.time() - start_time < duration:
        ret, frame = cap.read()
        if ret:
            frame_count += 1
            if frame_count % 30 == 0:
                print(f"[{app_name}] 已读取 {frame_count} 帧")
        else:
            print(f"[{app_name}] 读取失败")
            break
    
    cap.release()
    print(f"[{app_name}] ✓ 完成，共读取 {frame_count} 帧")
    return True

def test_multi_app_access():
    print("=" * 50)
    print("多应用访问测试")
    print("=" * 50)
    
    # 首先启动视频输出到虚拟摄像头
    print("启动视频输出...")
    
    def output_to_virtual_cam():
        cap = cv2.VideoCapture(0)  # 从真实摄像头读取
        out = cv2.VideoWriter('/dev/video20', 
                             cv2.VideoWriter_fourcc(*'MJPG'), 
                             30.0, (640, 480))
        
        start_time = time.time()
        while time.time() - start_time < 15:  # 输出15秒
            ret, frame = cap.read()
            if ret:
                out.write(frame)
            time.sleep(1/30)
        
        cap.release()
        out.release()
        print("[输出] 视频输出完成")
    
    # 启动输出线程
    output_thread = threading.Thread(target=output_to_virtual_cam)
    output_thread.start()
    
    # 等待输出开始
    time.sleep(2)
    
    # 启动多个"应用"读取
    print("\n启动多个应用读取虚拟摄像头...")
    
    apps = ["App1", "App2", "App3"]
    threads = []
    results = {}
    
    for app in apps:
        def make_reader(name):
            def reader():
                results[name] = read_from_virtual_cam(name, 10)
            return reader
        
        t = threading.Thread(target=make_reader(app))
        threads.append(t)
        t.start()
        time.sleep(0.5)  # 错开启动时间
    
    # 等待所有应用完成
    for t in threads:
        t.join()
    
    output_thread.join()
    
    # 汇总结果
    print("\n" + "=" * 50)
    print("多应用访问测试结果:")
    for app, success in results.items():
        print(f"  {app}: {'✓ 成功' if success else '✗ 失败'}")
    
    all_success = all(results.values())
    
    if all_success:
        print("\n✓ 多应用访问测试通过")
    else:
        print("\n✗ 多应用访问测试失败")
    
    return all_success

if __name__ == "__main__":
    success = test_multi_app_access()
    sys.exit(0 if success else 1)
EOF

# 执行测试
python3 /tmp/test_multi_app_access.py
```

### 步骤6: 稳定性测试

```bash
# 创建稳定性测试脚本
cat > /tmp/test_stability.py << 'EOF'
#!/usr/bin/env python3
import cv2
import time
import sys
import psutil
import os

def test_stability():
    print("=" * 50)
    print("虚拟摄像头稳定性测试")
    print("=" * 50)
    
    # 测试参数
    test_duration = 3600  # 1小时
    check_interval = 60   # 每分钟检查一次
    
    print(f"开始 {test_duration/60} 分钟稳定性测试...")
    
    # 启动视频输出
    cap = cv2.VideoCapture(0)
    out = cv2.VideoWriter('/dev/video20',
                         cv2.VideoWriter_fourcc(*'MJPG'),
                         30.0, (640, 480))
    
    if not out.isOpened():
        print("✗ 无法打开虚拟摄像头")
        return False
    
    process = psutil.Process(os.getpid())
    start_time = time.time()
    frame_count = 0
    errors = []
    memory_readings = []
    
    try:
        while time.time() - start_time < test_duration:
            ret, frame = cap.read()
            if ret:
                out.write(frame)
                frame_count += 1
            
            # 每分钟记录状态
            elapsed = time.time() - start_time
            if int(elapsed) % check_interval == 0:
                memory_mb = process.memory_info().rss / 1024 / 1024
                memory_readings.append(memory_mb)
                
                print(f"[{int(elapsed/60)}分钟] "
                      f"帧数: {frame_count}, "
                      f"内存: {memory_mb:.1f}MB")
            
            time.sleep(1/30)
            
    except KeyboardInterrupt:
        print("\n测试被用户中断")
    except Exception as e:
        errors.append(str(e))
        print(f"错误: {e}")
    
    finally:
        cap.release()
        out.release()
    
    # 分析结果
    print("\n" + "=" * 50)
    print("稳定性测试结果:")
    print(f"  运行时长: {elapsed/60:.1f}分钟")
    print(f"  总输出帧数: {frame_count}")
    print(f"  平均FPS: {frame_count/elapsed:.2f}")
    print(f"  错误次数: {len(errors)}")
    
    if memory_readings:
        import statistics
        avg_memory = statistics.mean(memory_readings)
        max_memory = max(memory_readings)
        memory_growth = memory_readings[-1] - memory_readings[0]
        
        print(f"\n内存使用:")
        print(f"  初始: {memory_readings[0]:.1f}MB")
        print(f"  平均: {avg_memory:.1f}MB")
        print(f"  峰值: {max_memory:.1f}MB")
        print(f"  增长: {memory_growth:.1f}MB")
        
        # 检查内存泄漏
        if memory_growth > 100:  # 增长超过100MB
            print("⚠ 警告: 可能存在内存泄漏")
    
    print("=" * 50)
    
    # 验证结果
    success = len(errors) == 0 and frame_count > 0
    
    if success:
        print("✓ 稳定性测试通过")
    else:
        print("✗ 稳定性测试失败")
    
    return success

if __name__ == "__main__":
    # 注意: 这个测试需要1小时，可以根据需要调整时长
    print("注意: 默认测试时长为1小时，按Ctrl+C可提前结束")
    success = test_stability()
    sys.exit(0 if success else 1)
EOF

echo "稳定性测试脚本已创建"
echo "运行命令: python3 /tmp/test_stability.py"
echo "注意: 测试需要1小时，可以修改脚本中的test_duration调整时长"
```

---

## 四、验证步骤

### 验证清单

- [ ] v4l2loopback模块加载成功
- [ ] 虚拟摄像头设备创建成功 (/dev/video20)
- [ ] 视频输出到虚拟摄像头成功
- [ ] OBS能识别虚拟摄像头
- [ ] 支持多应用同时访问
- [ ] 连续运行1小时无崩溃

### 验证命令

```bash
# 快速验证脚本
cat > /tmp/verify_task_6.4.sh << 'EOF'
#!/bin/bash
echo "========================================"
echo "任务6.4验证: AR-backend虚拟摄像头"
echo "========================================"

errors=0

# 1. 检查模块
echo -n "检查v4l2loopback模块... "
if lsmod | grep -q v4l2loopback; then
    echo "✓ 通过"
else
    echo "✗ 失败"
    errors=$((errors + 1))
fi

# 2. 检查设备
echo -n "检查虚拟摄像头设备... "
if [ -e "/dev/video20" ]; then
    echo "✓ 通过"
else
    echo "✗ 失败"
    errors=$((errors + 1))
fi

# 3. 检查设备属性
echo -n "检查设备属性... "
if v4l2-ctl --device=/dev/video20 --all > /dev/null 2>&1; then
    echo "✓ 通过"
else
    echo "⚠ 警告 (v4l2-ctl不可用)"
fi

echo "========================================"
if [ $errors -eq 0 ]; then
    echo "✓ 任务6.4基础验证通过"
    exit 0
else
    echo "✗ 任务6.4验证失败 ($errors 个错误)"
    exit 1
fi
EOF

chmod +x /tmp/verify_task_6.4.sh
/tmp/verify_task_6.4.sh
```

---

## 五、预期结果

### 成功标准

| 指标 | 目标值 | 验证方法 |
|------|--------|----------|
| 模块加载 | 成功 | lsmod检查 |
| 设备创建 | /dev/video20存在 | 文件检查 |
| 视频输出 | 成功 | 测试脚本 |
| OBS识别 | 成功 | 手动测试 |
| 多应用访问 | 支持 | 测试脚本 |
| 稳定性 | 1小时无崩溃 | 长时间测试 |

### 交付物

- [ ] 虚拟摄像头配置报告
- [ ] OBS集成测试报告
- [ ] 多应用访问测试报告
- [ ] 稳定性测试报告
- [ ] 验证通过标记

---

## 六、可能产生的问题及解决方案

| 问题 | 风险等级 | 产生原因 | 解决方式 | 预防方式 |
|------|----------|----------|----------|----------|
| 模块加载失败 | 高 | 内核版本不兼容 | 1. 安装对应版本模块<br>2. 编译安装<br>3. 升级内核 | 1. 兼容性检查脚本<br>2. 自动安装 |
| OBS无法识别 | 中 | 设备格式不支持 | 1. 调整输出格式<br>2. 使用兼容分辨率<br>3. 重启OBS | 1. 格式兼容性测试<br>2. 自动配置 |
| 画面卡顿 | 中 | 帧率或分辨率过高 | 1. 降低分辨率<br>2. 调整帧率<br>3. 优化编码 | 1. 性能基准测试<br>2. 自动降级 |
| 应用冲突 | 低 | 独占访问模式 | 1. 关闭其他应用<br>2. 使用非独占模式<br>3. 创建多个虚拟设备 | 1. 设备管理工具 |

---

## 七、执行检查点

- [ ] 模块加载成功
- [ ] 设备创建成功
- [ ] OBS集成测试通过
- [ ] 多应用访问测试通过
- [ ] 稳定性测试通过

---

## 八、关联文档

- [任务跟踪-阶段6-核心业务功能验证.md](./任务跟踪-阶段6-核心业务功能验证.md)
- [任务跟踪-阶段6-核心业务功能验证-部署任务6.3-AR-backend音频处理功能验证.md](./任务跟踪-阶段6-核心业务功能验证-部署任务6.3-AR-backend音频处理功能验证.md)
- [任务跟踪-阶段6-核心业务功能验证-部署任务6.5-User GUI启动和初始化验证.md](./任务跟踪-阶段6-核心业务功能验证-部署任务6.5-User GUI启动和初始化验证.md)

---

**创建时间:** 2026-02-11  
**最后更新:** 2026-02-11
