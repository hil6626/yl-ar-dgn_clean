# Phase 4 - Task 4.7: Create Unified Error Handling - Detailed Deployment Document

**Task ID:** 4.7  
**Task Name:** Create Unified Error Handling  
**Priority:** P2 (Medium)  
**Estimated Hours:** 2 hours  
**Status:** Pending  
**Prerequisites:** Task 4.6 completed

---

## I. Task Objectives

Create a unified error handling system for all scripts to ensure consistent error reporting and recovery.

## II. Deployment Content

### 2.1 Unified Error Handler (Python)

#### File: scripts/lib/error_handler.py

```python
#!/usr/bin/env python3
"""
Unified Error Handler
Provides consistent error handling across all scripts
"""

import sys
import traceback
import logging
from enum import Enum
from typing import Optional, Dict, Any, Callable
from functools import wraps


class ErrorCode(Enum):
    """Standard error codes"""
    SUCCESS = 0
    GENERAL_ERROR = 1
    INVALID_ARGUMENT = 2
    FILE_NOT_FOUND = 3
    PERMISSION_DENIED = 4
    NETWORK_ERROR = 5
    TIMEOUT = 6
    CONFIG_ERROR = 7
    DEPENDENCY_ERROR = 8
    VALIDATION_ERROR = 9
    RESOURCE_UNAVAILABLE = 10


class ScriptError(Exception):
    """
    Base script error
    """

    def __init__(self, message: str, code: ErrorCode = ErrorCode.GENERAL_ERROR,
                 details: Dict = None, recoverable: bool = False):
        super().__init__(message)
        self.message = message
        self.code = code
        self.details = details or {}
        self.recoverable = recoverable

    def to_dict(self) -> Dict:
        return {
            'error': True,
            'code': self.code.name,
            'code_value': self.code.value,
            'message': self.message,
            'details': self.details,
            'recoverable': self.recoverable
        }


class ValidationError(ScriptError):
    """Validation error"""
    def __init__(self, message: str, details: Dict = None):
        super().__init__(message, ErrorCode.VALIDATION_ERROR, details)


class ConfigError(ScriptError):
    """Configuration error"""
    def __init__(self, message: str, details: Dict = None):
        super().__init__(message, ErrorCode.CONFIG_ERROR, details)


class NetworkError(ScriptError):
    """Network error"""
    def __init__(self, message: str, details: Dict = None, recoverable: bool = True):
        super().__init__(message, ErrorCode.NETWORK_ERROR, details, recoverable)


class ErrorHandler:
    """
    Unified Error Handler
    """

    def __init__(self, logger_name: str = 'error_handler'):
        self.logger = logging.getLogger(logger_name)
        self.error_counts: Dict[ErrorCode, int] = {}
        self.recovery_strategies: Dict[ErrorCode, Callable] = {}

    def register_recovery(self, code: ErrorCode, strategy: Callable):
        """Register recovery strategy for error code"""
        self.recovery_strategies[code] = strategy

    def handle(self, error: Exception, context: str = "") -> Dict:
        """
        Handle an error
        """
        if isinstance(error, ScriptError):
            return self._handle_script_error(error, context)
        else:
            return self._handle_generic_error(error, context)

    def _handle_script_error(self, error: ScriptError, context: str) -> Dict:
        """Handle ScriptError"""
        # Log error
        self.logger.error(
            f"[{error.code.name}] {context}: {error.message}",
            extra={'details': error.details, 'code': error.code.value}
        )

        # Update count
        self.error_counts[error.code] = self.error_counts.get(error.code, 0) + 1

        # Attempt recovery if recoverable
        if error.recoverable and error.code in self.recovery_strategies:
            try:
                self.logger.info(f"Attempting recovery for {error.code.name}")
                self.recovery_strategies[error.code](error)
                return {**error.to_dict(), 'recovered': True}
            except Exception as recovery_error:
                self.logger.error(f"Recovery failed: {recovery_error}")

        return error.to_dict()

    def _handle_generic_error(self, error: Exception, context: str) -> Dict:
        """Handle generic exception"""
        self.logger.error(
            f"[UNEXPECTED] {context}: {str(error)}",
            exc_info=True
        )

        return {
            'error': True,
            'code': 'UNEXPECTED',
            'message': str(error),
            'traceback': traceback.format_exc(),
            'recoverable': False
        }

    def get_summary(self) -> Dict:
        """Get error summary"""
        return {
            'total_errors': sum(self.error_counts.values()),
            'by_code': {code.name: count for code, count in self.error_counts.items()},
            'has_errors': len(self.error_counts) > 0
        }


def with_error_handling(handler: Optional[ErrorHandler] = None):
    """
    Decorator for automatic error handling
    """
    error_handler = handler or ErrorHandler()

    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                result = error_handler.handle(e, context=func.__name__)
                if not result.get('recoverable') and not result.get('recovered'):
                    sys.exit(result.get('code_value', 1))
                return result
        return wrapper
    return decorator


# Global error handler
_global_handler = None

def get_error_handler() -> ErrorHandler:
    """Get global error handler"""
    global _global_handler
    if _global_handler is None:
        _global_handler = ErrorHandler()
    return _global_handler
```

### 2.2 Shell Error Handling

#### File: scripts/lib/error.sh

```bash
#!/bin/bash
# Shell Error Handling Functions

YL_ERROR_COUNT=0
YL_MAX_ERRORS=${YL_MAX_ERRORS:-10}
YL_ERROR_LOG="${YL_ERROR_LOG:-$(dirname "${BASH_SOURCE[0]}")/../../logs/errors.log}"

# Error codes
E_SUCCESS=0
E_GENERAL=1
E_INVALID_ARG=2
E_FILE_NOT_FOUND=3
E_PERMISSION=4
E_NETWORK=5
E_TIMEOUT=6
E_CONFIG=7
E_DEPENDENCY=8
E_VALIDATION=9
E_RESOURCE=10

# Ensure error log directory exists
mkdir -p "$(dirname "$YL_ERROR_LOG")"

# Error handling
yl_error() {
    local code=$1
    local message=$2
    local context="${3:-}"
    
    YL_ERROR_COUNT=$((YL_ERROR_COUNT + 1))
    
    # Log to file
    echo "$(date '+%Y-%m-%d %H:%M:%S') | ERROR | $code | $context | $message" >> "$YL_ERROR_LOG"
    
    # Output to stderr
    echo "[ERROR] $context: $message" >&2
    
    # Check max errors
    if [[ $YL_ERROR_COUNT -ge $YL_MAX_ERRORS ]]; then
        echo "[FATAL] Too many errors ($YL_ERROR_COUNT), aborting" >&2
        exit $E_GENERAL
    fi
    
    return $code
}

yl_fatal() {
    local code=$1
    local message=$2
    local context="${3:-}"
    
    yl_error "$code" "$message" "$context"
    exit $code
}

yl_try() {
    local cmd="$1"
    local error_msg="${2:-Command failed}"
    local error_code="${3:-$E_GENERAL}"
    
    if ! eval "$cmd"; then
        yl_error "$error_code" "$error_msg" "$cmd"
        return $error_code
    fi
    
    return $E_SUCCESS
}

yl_require() {
    local command=$1
    local error_msg="${2:-Required command not found: $command}"
    
    if ! command -v "$command" &> /dev/null; then
        yl_fatal $E_DEPENDENCY "$error_msg" "require"
    fi
}

yl_assert() {
    local condition=$1
    local message=$2
    
    if [[ -z "$condition" || "$condition" == "false" ]]; then
        yl_fatal $E_VALIDATION "Assertion failed: $message" "assert"
    fi
}

yl_cleanup_on_error() {
    local cleanup_cmd=$1
    YL_CLEANUP_CMD="$cleanup_cmd"
    trap 'yl_run_cleanup $?' ERR
}

yl_run_cleanup() {
    local exit_code=$1
    if [[ -n "$YL_CLEANUP_CMD" ]]; then
        echo "[CLEANUP] Running cleanup due to error (exit code: $exit_code)"
        eval "$YL_CLEANUP_CMD" || true
    fi
}

# Get error summary
yl_error_summary() {
    echo "Error Summary:"
    echo "  Total errors: $YL_ERROR_COUNT"
    if [[ -f "$YL_ERROR_LOG" ]]; then
        echo "  Recent errors:"
        tail -n 5 "$YL_ERROR_LOG"
    fi
}

# Example usage:
# source "$(dirname "$0")/../lib/error.sh"
# yl_require "python3"
# yl_try "ls /nonexistent" "Directory not found" $E_FILE_NOT_FOUND
# yl_assert "$var" "Variable must be set"
```

## III. Deployment Steps

```bash
# 1. Create error handler
# Edit scripts/lib/error_handler.py

# 2. Create shell error handling
# Edit scripts/lib/error.sh

# 3. Test Python error handler
python3 -c "
from scripts.lib.error_handler import ErrorHandler, ScriptError, ErrorCode
handler = ErrorHandler()
try:
    raise ScriptError('Test error', ErrorCode.VALIDATION_ERROR)
except Exception as e:
    result = handler.handle(e, 'test_context')
    print(result)
"

# 4. Test shell error handling
source scripts/lib/error.sh
yl_error $E_GENERAL "Test error" "test_context"
yl_error_summary
```

## IV. Verification Checklist

- [ ] Python error handler created
- [ ] Shell error handling created
- [ ] Error codes defined
- [ ] Recovery strategies work
- [ ] Error logging works
- [ ] Cleanup on error works

## V. Next Step

After completing this task, proceed to **Task 4.8: Script Validation Testing**

View document: `部署/任务跟踪-阶段4-脚本整合-部署任务4.8-脚本验证测试.md`
