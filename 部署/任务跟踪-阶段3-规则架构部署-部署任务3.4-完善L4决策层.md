# Phase 3 - Task 3.4: Improve L4 Decision Layer - Detailed Deployment Document

**Task ID:** 3.4  
**Task Name:** Improve L4 Decision Layer  
**Priority:** P1 (High)  
**Estimated Hours:** 2 hours  
**Status:** Pending  
**Prerequisites:** Task 3.3 completed

---

## I. Task Objectives

Improve the L4 Decision layer rules to define decision-making logic, strategies, and action plans.

## II. Deployment Content

### 2.1 Files to Create/Modify

| No. | File Path | Operation | Description |
|-----|-----------|-----------|-------------|
| 1 | `rules/L4-decisions.json` | Modify | Improve decision rules |
| 2 | `rules/decision_engine.py` | New | Decision engine |

### 2.2 Detailed Code Implementation

#### File 1: rules/L4-decisions.json

```json
{
  "layer": "L4",
  "name": "decisions",
  "description": "Decision layer - defines decision-making strategies and action plans",
  "version": "1.0.0",
  "last_updated": "2026-02-09",
  "decision_rules": [
    {
      "id": "D1",
      "name": "Service Startup Order",
      "description": "Determines the order of service startup",
      "trigger": "System startup command received",
      "conditions": [
        "All service binaries are present",
        "Required ports are available",
        "Configuration files are valid"
      ],
      "actions": [
        {"step": 1, "service": "YL-monitor", "action": "start", "delay": 0},
        {"step": 2, "service": "AR-backend", "action": "start", "delay": 5},
        {"step": 3, "service": "User GUI", "action": "start", "delay": 10},
        {"step": 4, "action": "verify_all_healthy", "delay": 15}
      ],
      "rollback": {
        "on_failure": "stop_all_and_notify",
        "timeout": 60
      },
      "priority": 1
    },
    {
      "id": "D2",
      "name": "Service Failure Recovery",
      "description": "Handles service failure detection and recovery",
      "trigger": "Health check failure or heartbeat timeout",
      "conditions": [
        "Service not responding for > 60 seconds",
        "Service reports unhealthy status",
        "Multiple consecutive failures"
      ],
      "actions": [
        {"step": 1, "action": "log_failure", "level": "error"},
        {"step": 2, "action": "send_alert", "channels": ["log", "dashboard"]},
        {"step": 3, "action": "attempt_restart", "max_retries": 3},
        {"step": 4, "action": "escalate_if_still_failing", "delay": 300}
      ],
      "priority": 0
    },
    {
      "id": "D3",
      "name": "Resource Scaling Decision",
      "description": "Decides when to scale resources or reduce load",
      "trigger": "Resource usage threshold exceeded",
      "conditions": [
        "CPU > 80% for 5 minutes",
        "Memory > 90% for 3 minutes",
        "Disk > 85% full"
      ],
      "actions": [
        {"step": 1, "action": "log_high_usage", "level": "warning"},
        {"step": 2, "action": "reduce_non_essential_features"},
        {"step": 3, "action": "notify_admin", "urgency": "high"},
        {"step": 4, "action": "suggest_scaling", "if_sustained": 600}
      ],
      "priority": 2
    },
    {
      "id": "D4",
      "name": "Security Incident Response",
      "description": "Handles security alerts and incidents",
      "trigger": "Security alert or anomaly detected",
      "conditions": [
        "Unauthorized access attempt",
        "Unusual traffic pattern",
        "Failed authentication threshold exceeded"
      ],
      "actions": [
        {"step": 1, "action": "log_security_event", "level": "critical"},
        {"step": 2, "action": "isolate_affected_component"},
        {"step": 3, "action": "enable_audit_mode"},
        {"step": 4, "action": "notify_security_team", "immediate": true},
        {"step": 5, "action": "preserve_evidence"}
      ],
      "priority": 0
    },
    {
      "id": "D5",
      "name": "Deployment Decision",
      "description": "Decides when and how to deploy updates",
      "trigger": "New version ready for deployment",
      "conditions": [
        "All tests passed",
        "Maintenance window active",
        "Backup completed",
        "Rollback plan prepared"
      ],
      "actions": [
        {"step": 1, "action": "notify_users", "message": "maintenance_starting"},
        {"step": 2, "action": "create_backup_point"},
        {"step": 3, "action": "deploy_new_version"},
        {"step": 4, "action": "run_smoke_tests"},
        {"step": 5, "action": "notify_completion_or_rollback"}
      ],
      "priority": 1
    },
    {
      "id": "D6",
      "name": "Configuration Update",
      "description": "Handles dynamic configuration updates",
      "trigger": "Configuration change requested",
      "conditions": [
        "Change is authorized",
        "Change passes validation",
        "No conflicting changes pending"
      ],
      "actions": [
        {"step": 1, "action": "validate_change"},
        {"step": 2, "action": "create_config_backup"},
        {"step": 3, "action": "apply_change"},
        {"step": 4, "action": "verify_change"},
        {"step": 5, "action": "rollback_if_failed"}
      ],
      "priority": 2
    }
  ],
  "priority_definitions": {
    "P0": {
      "name": "Critical",
      "description": "Immediate action required",
      "response_time": "< 1 minute",
      "escalation": "immediate"
    },
    "P1": {
      "name": "High",
      "description": "Action required within short timeframe",
      "response_time": "< 15 minutes",
      "escalation": "after 30 minutes"
    },
    "P2": {
      "name": "Medium",
      "description": "Action required within reasonable timeframe",
      "response_time": "< 4 hours",
      "escalation": "after 8 hours"
    },
    "P3": {
      "name": "Low",
      "description": "Action can be deferred",
      "response_time": "< 24 hours",
      "escalation": "after 48 hours"
    }
  },
  "decision_strategies": {
    "consensus": "Require agreement from multiple sources",
    "authority": "Decision made by designated authority",
    "automation": "Fully automated decision based on rules",
    "hybrid": "Automated with human oversight"
  }
}
```

#### File 2: rules/decision_engine.py

```python
#!/usr/bin/env python3
"""
Decision Engine
Executes decision rules based on context
"""

import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Callable

logger = logging.getLogger('DecisionEngine')


class DecisionEngine:
    """
    Decision Engine
    """

    def __init__(self):
        self.decisions = {}
        self.actions = {}
        self.load_decisions()

    def load_decisions(self):
        """Load L4 decisions"""
        decisions_file = Path(__file__).parent / 'L4-decisions.json'
        if decisions_file.exists():
            with open(decisions_file) as f:
                data = json.load(f)
                for decision in data.get('decision_rules', []):
                    self.decisions[decision['id']] = decision

        # Register actions
        self.register_action('log_failure', self._action_log)
        self.register_action('send_alert', self._action_alert)
        self.register_action('attempt_restart', self._action_restart)

    def register_action(self, name: str, func: Callable):
        """Register an action handler"""
        self.actions[name] = func

    def evaluate_decision(self, decision_id: str, context: Dict) -> bool:
        """
        Evaluate if a decision should be triggered
        """
        decision = self.decisions.get(decision_id)
        if not decision:
            return False

        # Check conditions
        conditions = decision.get('conditions', [])
        # Simplified - in real implementation, evaluate each condition

        return True

    def execute_decision(self, decision_id: str, context: Dict) -> Dict:
        """
        Execute a decision
        """
        decision = self.decisions.get(decision_id)
        if not decision:
            return {'success': False, 'error': 'Decision not found'}

        results = {
            'decision_id': decision_id,
            'steps_executed': [],
            'success': True
        }

        for step in decision.get('actions', []):
            action_name = step.get('action')
            if action_name in self.actions:
                try:
                    self.actions[action_name](step, context)
                    results['steps_executed'].append(step)
                except Exception as e:
                    logger.error(f"Action failed: {e}")
                    results['success'] = False
                    break

        return results

    def _action_log(self, step: Dict, context: Dict):
        """Log action"""
        level = step.get('level', 'info')
        message = f"Decision action: {step}"
        getattr(logger, level)(message)

    def _action_alert(self, step: Dict, context: Dict):
        """Send alert"""
        channels = step.get('channels', ['log'])
        for channel in channels:
            logger.info(f"Alert via {channel}: {context}")

    def _action_restart(self, step: Dict, context: Dict):
        """Attempt restart"""
        max_retries = step.get('max_retries', 3)
        logger.info(f"Attempting restart (max {max_retries} retries)")


def main():
    """Main function"""
    engine = DecisionEngine()

    # Test
    context = {'service': 'test', 'status': 'failed'}
    result = engine.execute_decision('D2', context)
    print(f"Decision result: {result}")


if __name__ == '__main__':
    main()
```

## III. Deployment Steps

```bash
# 1. Create L4 decisions file
# Edit rules/L4-decisions.json

# 2. Create decision engine
# Edit rules/decision_engine.py

# 3. Validate JSON
python3 -c "import json; json.load(open('rules/L4-decisions.json'))"

# 4. Test decision engine
python3 rules/decision_engine.py
```

## IV. Verification Checklist

- [ ] L4 decisions file created
- [ ] Decision rules defined
- [ ] Priority levels set
- [ ] Decision engine works
- [ ] Actions can be executed

## V. Next Step

After completing this task, proceed to **Task 3.5: Improve L5 Execution Layer**

View document: `部署/任务跟踪-阶段3-规则架构部署-部署任务3.5-完善L5执行层.md`
