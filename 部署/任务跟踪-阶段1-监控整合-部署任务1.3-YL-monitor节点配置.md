# 阶段1 - 任务1.3: YL-monitor 节点配置 - 详细部署文档

**任务ID:** 1.3  
**任务名称:** YL-monitor 节点配置  
**优先级:** P0（阻塞性）  
**预计工时:** 3小时  
**状态:** 待执行  
**前置依赖:** 任务1.1和1.2完成

---

## 一、任务目标

在 YL-monitor 中配置 AR-backend 和 User GUI 节点，实现健康检查轮询和状态管理。

## 二、部署内容

### 2.1 修改文件清单

| 序号 | 文件路径 | 操作类型 | 说明 |
|------|----------|----------|------|
| 1 | `YL-monitor/app/services/ar_monitor.py` | 修改 | 添加节点配置和检查逻辑 |
| 2 | `YL-monitor/app/config/nodes.yaml` | 新建 | 节点配置文件 |
| 3 | `YL-monitor/app/routes/ar.py` | 修改 | 添加节点管理API |
| 4 | `YL-monitor/app/main.py` | 修改 | 初始化节点监控 |

### 2.2 详细代码实现

#### 文件1: 修改 YL-monitor/app/services/ar_monitor.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AR 节点监控服务
管理 AR-backend 和 User GUI 节点的健康检查和状态监控
"""

import os
import yaml
import asyncio
import aiohttp
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, field
from pathlib import Path

logger = logging.getLogger('ARMonitor')


@dataclass
class NodeInfo:
    """节点信息"""
    node_id: str
    node_name: str
    node_type: str  # 'ar-backend' 或 'user-gui'
    host: str
    port: int
    health_endpoint: str
    status_endpoint: str
    check_interval: int = 30  # 秒
    timeout: int = 5  # 秒
    fail_threshold: int = 3  # 连续失败次数标记离线
    
    # 运行时状态
    status: str = 'unknown'  # online, offline, error
    last_check: Optional[datetime] = None
    last_heartbeat: Optional[datetime] = None
    consecutive_fails: int = 0
    metadata: Dict = field(default_factory=dict)
    
    @property
    def base_url(self) -> str:
        """获取基础URL"""
        return f"http://{self.host}:{self.port}"
    
    @property
    def is_online(self) -> bool:
        """检查是否在线"""
        if self.status != 'online':
            return False
        if self.last_heartbeat:
            # 心跳超时检查（2倍检查间隔）
            timeout = timedelta(seconds=self.check_interval * 2)
            if datetime.utcnow() - self.last_heartbeat > timeout:
                return False
        return True


class ARMonitor:
    """
    AR 节点监控器
    """
    
    def __init__(self, config_path: Optional[str] = None):
        self.nodes: Dict[str, NodeInfo] = {}
        self.config_path = config_path or self._find_config()
        self.session: Optional[aiohttp.ClientSession] = None
        self.check_task: Optional[asyncio.Task] = None
        self.running = False
        
        # 加载配置
        self._load_config()
        
    def _find_config(self) -> Optional[str]:
        """查找配置文件"""
        possible_paths = [
            Path(__file__).parent.parent / 'config' / 'nodes.yaml',
            Path.cwd() / 'config' / 'nodes.yaml',
            Path('/etc/yl-monitor/nodes.yaml'),
        ]
        
        for path in possible_paths:
            if path.exists():
                return str(path)
        return None
    
    def _load_config(self):
        """加载节点配置"""
        if not self.config_path or not Path(self.config_path).exists():
            logger.warning("未找到节点配置文件，使用默认配置")
            self._create_default_config()
            return
            
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
                
            for node_config in config.get('nodes', []):
                node = NodeInfo(**node_config)
                self.nodes[node.node_id] = node
                logger.info(f"加载节点配置: {node.node_id} ({node.node_name})")
                
        except Exception as e:
            logger.error(f"加载配置失败: {e}")
            
    def _create_default_config(self):
        """创建默认配置"""
        default_nodes = [
            NodeInfo(
                node_id='ar-backend',
                node_name='AR Backend Service',
                node_type='ar-backend',
                host='localhost',
                port=5501,
                health_endpoint='/health',
                status_endpoint='/status'
            ),
            NodeInfo(
                node_id='user-gui',
                node_name='User GUI Application',
                node_type='user-gui',
                host='localhost',
                port=5502,
                health_endpoint='/health',
                status_endpoint='/status'
            )
        ]
        
        for node in default_nodes:
            self.nodes[node.node_id] = node
            
        # 保存默认配置
        if self.config_path:
            self._save_config()
    
    def _save_config(self):
        """保存配置到文件"""
        try:
            config = {
                'nodes': [
                    {
                        'node_id': node.node_id,
                        'node_name': node.node_name,
                        'node_type': node.node_type,
                        'host': node.host,
                        'port': node.port,
                        'health_endpoint': node.health_endpoint,
                        'status_endpoint': node.status_endpoint,
                        'check_interval': node.check_interval,
                        'timeout': node.timeout,
                        'fail_threshold': node.fail_threshold
                    }
                    for node in self.nodes.values()
                ]
            }
            
            Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w', encoding='utf-8') as f:
                yaml.dump(config, f, default_flow_style=False, allow_unicode=True)
                
        except Exception as e:
            logger.error(f"保存配置失败: {e}")
    
    async def start_monitoring(self):
        """启动监控"""
        if self.running:
            return
            
        self.running = True
        self.session = aiohttp.ClientSession()
        
        # 启动定期检查任务
        self.check_task = asyncio.create_task(self._check_loop())
        
        logger.info(f"AR监控服务启动，监控 {len(self.nodes)} 个节点")
        
    async def stop_monitoring(self):
        """停止监控"""
        self.running = False
        
        if self.check_task:
            self.check_task.cancel()
            try:
                await self.check_task
            except asyncio.CancelledError:
                pass
                
        if self.session:
            await self.session.close()
            
        logger.info("AR监控服务已停止")
    
    async def _check_loop(self):
        """检查循环"""
        while self.running:
            try:
                await self._check_all_nodes()
            except Exception as e:
                logger.error(f"检查循环异常: {e}")
                
            # 等待下一次检查（使用较短的间隔以便快速响应）
            await asyncio.sleep(10)
    
    async def _check_all_nodes(self):
        """检查所有节点"""
        tasks = [self._check_node(node) for node in self.nodes.values()]
        await asyncio.gather(*tasks, return_exceptions=True)
    
    async def _check_node(self, node: NodeInfo):
        """检查单个节点"""
        try:
            url = f"{node.base_url}{node.health_endpoint}"
            
            async with self.session.get(
                url, 
                timeout=aiohttp.ClientTimeout(total=node.timeout)
            ) as response:
                
                if response.status == 200:
                    data = await response.json()
                    
                    # 更新节点状态
                    node.status = 'online'
                    node.last_check = datetime.utcnow()
                    node.consecutive_fails = 0
                    
                    # 合并返回的元数据
                    if isinstance(data, dict):
                        node.metadata.update(data)
                        
                    logger.debug(f"节点 {node.node_id} 健康检查通过")
                    
                else:
                    # HTTP错误
                    node.consecutive_fails += 1
                    logger.warning(
                        f"节点 {node.node_id} 健康检查失败: HTTP {response.status}"
                    )
                    
        except asyncio.TimeoutError:
            node.consecutive_fails += 1
            logger.warning(f"节点 {node.node_id} 健康检查超时")
            
        except Exception as e:
            node.consecutive_fails += 1
            logger.error(f"节点 {node.node_id} 健康检查异常: {e}")
        
        # 检查是否达到失败阈值
        if node.consecutive_fails >= node.fail_threshold:
            if node.status != 'offline':
                node.status = 'offline'
                logger.error(f"节点 {node.node_id} 标记为离线")
                
                # 触发告警
                await self._trigger_alert(node, 'node_offline')
    
    async def _trigger_alert(self, node: NodeInfo, alert_type: str):
        """触发告警"""
        logger.warning(f"触发告警: {alert_type} - {node.node_id}")
        # 这里可以集成告警系统
        # 例如：发送邮件、钉钉通知等
    
    def update_heartbeat(self, node_id: str, data: dict):
        """更新节点心跳（由API调用）"""
        if node_id not in self.nodes:
            # 自动注册新节点
            logger.info(f"自动注册新节点: {node_id}")
            self._auto_register_node(node_id, data)
            return
            
        node = self.nodes[node_id]
        node.last_heartbeat = datetime.utcnow()
        node.status = data.get('status', 'unknown')
        
        # 更新元数据
        if 'gui' in data:
            node.metadata['gui'] = data['gui']
        if 'resources' in data:
            node.metadata['resources'] = data['resources']
            
        # 重置失败计数
        if node.consecutive_fails > 0:
            logger.info(f"节点 {node_id} 恢复在线")
            node.consecutive_fails = 0
            
    def _auto_register_node(self, node_id: str, data: dict):
        """自动注册节点"""
        node_type = data.get('node_type', 'unknown')
        
        # 根据类型确定端口
        port_map = {
            'ar-backend': 5501,
            'user-gui': 5502
        }
        
        node = NodeInfo(
            node_id=node_id,
            node_name=data.get('node_name', node_id),
            node_type=node_type,
            host='localhost',
            port=port_map.get(node_type, 5500),
            health_endpoint='/health',
            status_endpoint='/status'
        )
        
        self.nodes[node_id] = node
        logger.info(f"节点 {node_id} 已自动注册")
    
    def get_node(self, node_id: str) -> Optional[NodeInfo]:
        """获取节点信息"""
        return self.nodes.get(node_id)
    
    def get_all_nodes(self) -> List[NodeInfo]:
        """获取所有节点"""
        return list(self.nodes.values())
    
    def get_online_nodes(self) -> List[NodeInfo]:
        """获取在线节点"""
        return [n for n in self.nodes.values() if n.is_online]
    
    def get_offline_nodes(self) -> List[NodeInfo]:
        """获取离线节点"""
        return [n for n in self.nodes.values() if not n.is_online]
    
    async def get_node_status(self, node_id: str) -> Optional[dict]:
        """获取节点详细状态"""
        node = self.nodes.get(node_id)
        if not node:
            return None
            
        try:
            url = f"{node.base_url}{node.status_endpoint}"
            async with self.session.get(
                url,
                timeout=aiohttp.ClientTimeout(total=node.timeout)
            ) as response:
                
                if response.status == 200:
                    return await response.json()
                    
        except Exception as e:
            logger.error(f"获取节点 {node_id} 状态失败: {e}")
            
        return None
```

#### 文件2: 新建 YL-monitor/app/config/nodes.yaml

```yaml
# AR 节点配置
# 配置 AR-backend 和 User GUI 节点的监控参数

nodes:
  - node_id: ar-backend
    node_name: AR Backend Service
    node_type: ar-backend
    host: localhost
    port: 5501
    health_endpoint: /health
    status_endpoint: /status
    check_interval: 30
    timeout: 5
    fail_threshold: 3

  - node_id: user-gui
    node_name: User GUI Application
    node_type: user-gui
    host: localhost
    port: 5502
    health_endpoint: /health
    status_endpoint: /status
    check_interval: 30
    timeout: 5
    fail_threshold: 3

# 告警配置
alerts:
  enabled: true
  channels:
    - type: log
      enabled: true
    - type: webhook
      enabled: false
      url: ""
    - type: email
      enabled: false
      smtp_server: ""
      smtp_port: 587
      username: ""
      password: ""
      to_addresses: []

# 数据保留配置
retention:
  heartbeat_history_days: 7
  status_history_days: 30
```

#### 文件3: 修改 YL-monitor/app/routes/ar.py

添加节点管理API：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AR 监控路由
提供节点管理和状态查询API
"""

from fastapi import APIRouter, HTTPException, Request, BackgroundTasks
from pydantic import BaseModel
from typing import Dict, List, Optional
from datetime import datetime

router = APIRouter(prefix="/api/ar", tags=["AR监控"])


class NodeHeartbeat(BaseModel):
    """节点心跳数据"""
    node_id: str
    node_name: Optional[str] = None
    status: str
    timestamp: str
    version: Optional[str] = None
    uptime: Optional[float] = None
    resources: Optional[Dict] = None
    gui: Optional[Dict] = None


class NodeResponse(BaseModel):
    """节点响应"""
    node_id: str
    node_name: str
    node_type: str
    status: str
    is_online: bool
    last_check: Optional[str] = None
    last_heartbeat: Optional[str] = None
    metadata: Optional[Dict] = None


def get_monitor(request: Request):
    """获取监控服务实例"""
    monitor = getattr(request.app.state, 'ar_monitor', None)
    if not monitor:
        raise HTTPException(status_code=503, detail="AR监控服务未初始化")
    return monitor


@router.get("/nodes", response_model=List[NodeResponse])
async def list_nodes(request: Request):
    """获取所有节点列表"""
    monitor = get_monitor(request)
    
    nodes = []
    for node in monitor.get_all_nodes():
        nodes.append(NodeResponse(
            node_id=node.node_id,
            node_name=node.node_name,
            node_type=node.node_type,
            status=node.status,
            is_online=node.is_online,
            last_check=node.last_check.isoformat() if node.last_check else None,
            last_heartbeat=node.last_heartbeat.isoformat() if node.last_heartbeat else None,
            metadata=node.metadata
        ))
    
    return nodes


@router.get("/nodes/{node_id}", response_model=NodeResponse)
async def get_node(node_id: str, request: Request):
    """获取指定节点信息"""
    monitor = get_monitor(request)
    node = monitor.get_node(node_id)
    
    if not node:
        raise HTTPException(status_code=404, detail=f"节点 {node_id} 不存在")
    
    return NodeResponse(
        node_id=node.node_id,
        node_name=node.node_name,
        node_type=node.node_type,
        status=node.status,
        is_online=node.is_online,
        last_check=node.last_check.isoformat() if node.last_check else None,
        last_heartbeat=node.last_heartbeat.isoformat() if node.last_heartbeat else None,
        metadata=node.metadata
    )


@router.post("/nodes/{node_id}/heartbeat")
async def node_heartbeat(
    node_id: str,
    heartbeat: NodeHeartbeat,
    request: Request,
    background_tasks: BackgroundTasks
):
    """接收节点心跳"""
    monitor = get_monitor(request)
    
    # 验证node_id匹配
    if heartbeat.node_id != node_id:
        raise HTTPException(status_code=400, detail="node_id不匹配")
    
    # 更新心跳
    monitor.update_heartbeat(node_id, heartbeat.dict())
    
    return {
        "status": "success",
        "message": "心跳已接收",
        "timestamp": datetime.utcnow().isoformat() + "Z"
    }


@router.get("/nodes/{node_id}/status")
async def get_node_status(node_id: str, request: Request):
    """获取节点实时状态"""
    monitor = get_monitor(request)
    
    status = await monitor.get_node_status(node_id)
    if not status:
        raise HTTPException(status_code=503, detail=f"无法获取节点 {node_id} 状态")
    
    return status


@router.get("/summary")
async def get_summary(request: Request):
    """获取监控摘要"""
    monitor = get_monitor(request)
    
    all_nodes = monitor.get_all_nodes()
    online_nodes = monitor.get_online_nodes()
    offline_nodes = monitor.get_offline_nodes()
    
    return {
        "total_nodes": len(all_nodes),
        "online_nodes": len(online_nodes),
        "offline_nodes": len(offline_nodes),
        "health_rate": len(online_nodes) / len(all_nodes) if all_nodes else 0,
        "nodes": [
            {
                "node_id": n.node_id,
                "node_name": n.node_name,
                "status": n.status,
                "is_online": n.is_online
            }
            for n in all_nodes
        ],
        "timestamp": datetime.utcnow().isoformat() + "Z"
    }
```

#### 文件4: 修改 YL-monitor/app/main.py

在应用启动时初始化AR监控：

```python
# 在 lifespan 函数中添加AR监控初始化

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # ... 其他初始化代码 ...
    
    # 初始化 AR 监控器
    try:
        from app.services.ar_monitor import ARMonitor
        ar_monitor = ARMonitor()
        await ar_monitor.start_monitoring()
        app.state.ar_monitor = ar_monitor
        logger.info(f"✓ AR 监控器已启动，监控 {len(ar_monitor.nodes)} 个节点")
    except Exception as e:
        logger.error(f"✗ AR 监控器启动失败: {e}")
        app.state.ar_monitor = None
    
    # ... 其他初始化代码 ...
    
    # 关闭时清理
    yield
    
    # 停止AR监控
    if hasattr(app.state, 'ar_monitor') and app.state.ar_monitor:
        await app.state.ar_monitor.stop_monitoring()
        logger.info("✓ AR 监控器已停止")
```

## 三、关联内容修复

### 3.1 需要同步修复的文件

| 文件 | 修复内容 | 原因 |
|------|----------|------|
| `YL-monitor/app/main.py` | 添加AR监控初始化和关闭 | 生命周期管理 |
| `YL-monitor/app/routes/__init__.py` | 注册AR路由 | 路由集成 |
| `YL-monitor/requirements.txt` | 添加aiohttp依赖 | 异步HTTP客户端 |

### 3.2 详细修复说明

#### 修复1: YL-monitor/app/routes/__init__.py

```python
from fastapi import APIRouter

# 导入各模块路由
from app.routes import dag, scripts, dashboard
from app.routes import ar  # 新增AR监控路由

def register_routers(app):
    """注册所有路由"""
    # ... 其他路由 ...
    
    # AR监控路由
    app.include_router(ar.router)
```

#### 修复2: YL-monitor/requirements.txt

添加依赖：
```text
aiohttp>=3.8.0
```

## 四、部署执行步骤

### 4.1 执行前检查

```bash
# 1. 确认任务1.1和1.2已完成
curl http://localhost:5501/health  # AR-backend
curl http://localhost:5502/health  # User GUI

# 2. 检查依赖
pip list | grep aiohttp
```

### 4.2 部署执行

```bash
# 1. 创建配置文件
mkdir -p YL-monitor/app/config
# 创建 nodes.yaml

# 2. 修改 ar_monitor.py
# 修改 ar.py 路由
# 修改 main.py 初始化

# 3. 安装依赖
pip install aiohttp

# 4. 重启YL-monitor
cd YL-monitor
uvicorn app.main:app --reload --host 0.0.0.0 --port 5500
```

### 4.3 部署验证

```bash
# 1. 检查节点列表
curl http://localhost:5500/api/ar/nodes

# 2. 检查AR-backend节点
curl http://localhost:5500/api/ar/nodes/ar-backend

# 3. 检查User GUI节点
curl http://localhost:5500/api/ar/nodes/user-gui

# 4. 检查监控摘要
curl http://localhost:5500/api/ar/summary

# 5. 发送测试心跳
curl -X POST http://localhost:5500/api/ar/nodes/test-node/heartbeat \
  -H "Content-Type: application/json" \
  -d '{"node_id":"test-node","status":"running","timestamp":"2026-02-09T10:00:00Z"}'
```

## 五、常见问题及解决

### 问题1: 节点显示离线

**现象:** 节点状态为offline

**解决:**
```bash
# 检查被监控服务
curl http://localhost:5501/health

# 检查YL-monitor日志
tail -f YL-monitor/logs/app.log

# 检查配置
cat YL-monitor/app/config/nodes.yaml
```

### 问题2: 心跳接收失败

**现象:** 404错误或无法接收心跳

**解决:**
```python
# 确认路由已注册
# 检查 app/routes/__init__.py 是否包含 ar.router

# 检查main.py中监控器是否初始化
```

### 问题3: 异步任务异常

**现象:** 监控循环停止

**解决:**
```python
# 检查异常处理
# 确保所有异步操作有try-except
# 查看日志定位问题
```

## 六、验证清单

- [ ] ar_monitor.py 修改完成
- [ ] nodes.yaml 配置正确
- [ ] ar.py 路由添加完成
- [ ] main.py 初始化修改完成
- [ ] 依赖安装完成（aiohttp）
- [ ] 路由注册完成
- [ ] /api/ar/nodes 返回正确
- [ ] /api/ar/nodes/{id} 返回正确
- [ ] 心跳接收正常
- [ ] 节点状态更新正确

## 七、下一步

完成本任务后，继续执行 **任务1.4: 统一监控面板配置**

查看文档: `部署/任务跟踪-阶段1-监控整合-部署任务1.4-统一监控面板配置.md`
