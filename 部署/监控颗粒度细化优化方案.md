# YL-AR-DGN 监控颗粒度细化优化方案

**版本:** 1.0.0  
**创建日期:** 2026-02-16  
**状态:** 优化建议

---

## 📊 当前监控现状分析

### 现有监控架构

```
┌─────────────────────────────────────────┐
│           YL-Monitor (5500)            │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐  │
│  │ 健康检查 │ │ 状态查询 │ │ 指标收集 │  │
│  └─────────┘ └─────────┘ └─────────┘  │
└─────────────────────────────────────────┘
              │
    ┌─────────┼─────────┐
    ▼         ▼         ▼
┌────────┐ ┌────────┐ ┌────────┐
│AR-backend│ │User GUI│ │ Scripts│
│ (5501)  │ │ (5502) │ │        │
└────────┘ └────────┘ └────────┘
```

### 现有监控指标

| 层级 | 指标 | 粒度 | 频率 |
|------|------|------|------|
| **服务层** | 健康状态 | 布尔值 | 30秒 |
| **服务层** | 运行状态 | 字符串 | 30秒 |
| **系统层** | CPU/内存/磁盘 | 百分比 | 60秒 |
| **应用层** | 基本指标 | 少量 | 60秒 |

### 存在的问题

1. **监控粒度粗**: 只有服务级监控，缺少模块级、功能级监控
2. **指标维度少**: 缺少业务指标、性能指标、用户体验指标
3. **采集频率低**: 30-60秒采集一次，无法捕捉瞬时异常
4. **缺少关联分析**: 各组件监控数据孤立，无法关联分析
5. **告警滞后**: 发现问题时可能已经影响用户体验

---

## 🎯 监控颗粒度细化方案

### 五层监控架构

```
┌─────────────────────────────────────────────────────────────┐
│ L5: 用户体验层 (User Experience Layer)                      │
│ 页面加载时间、操作响应时间、用户满意度                        │
├─────────────────────────────────────────────────────────────┤
│ L4: 业务功能层 (Business Logic Layer)                        │
│ 视频处理成功率、人脸合成质量、音频处理延迟                    │
├─────────────────────────────────────────────────────────────┤
│ L3: 应用服务层 (Application Service Layer)                   │
│ API响应时间、错误率、吞吐量、并发数                          │
├─────────────────────────────────────────────────────────────┤
│ L2: 系统资源层 (System Resource Layer)                       │
│ CPU/内存/磁盘/网络/GPU 细粒度指标                            │
├─────────────────────────────────────────────────────────────┤
│ L1: 基础设施层 (Infrastructure Layer)                        │
│ 进程状态、端口状态、文件描述符、线程状态                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 📈 细化监控指标设计

### L1: 基础设施层（最细粒度）

#### 1.1 进程级监控

```python
# YL-monitor/app/services/infrastructure_monitor.py

class ProcessMonitor:
    """进程级监控器"""
    
    def collect_process_metrics(self, pid: int) -> dict:
        """采集进程级指标"""
        process = psutil.Process(pid)
        
        return {
            "pid": pid,
            "name": process.name(),
            "status": process.status(),  # running, sleeping, zombie...
            "cpu_percent": process.cpu_percent(interval=1),
            "memory_info": {
                "rss": process.memory_info().rss,      # 实际使用内存
                "vms": process.memory_info().vms,      # 虚拟内存
                "shared": process.memory_info().shared, # 共享内存
                "percent": process.memory_percent()
            },
            "io_counters": {
                "read_bytes": process.io_counters().read_bytes,
                "write_bytes": process.io_counters().write_bytes,
                "read_count": process.io_counters().read_count,
                "write_count": process.io_counters().write_count
            },
            "num_threads": process.num_threads(),
            "num_fds": process.num_fds(),  # 文件描述符数量
            "open_files": len(process.open_files()),  # 打开文件数
            "connections": len(process.connections()),  # 网络连接数
            "ctx_switches": {
                "voluntary": process.num_ctx_switches().voluntary,
                "involuntary": process.num_ctx_switches().involuntary
            },
            "cpu_times": {
                "user": process.cpu_times().user,
                "system": process.cpu_times().system,
                "children_user": process.cpu_times().children_user,
                "children_system": process.cpu_times().children_system
            },
            "timestamp": datetime.now().isoformat()
        }
```

#### 1.2 端口级监控

```python
class PortMonitor:
    """端口级监控器"""
    
    def monitor_port_details(self, host: str, port: int) -> dict:
        """监控端口详细信息"""
        import socket
        import time
        
        metrics = {
            "host": host,
            "port": port,
            "timestamp": datetime.now().isoformat()
        }
        
        # 连接测试
        start_time = time.time()
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((host, port))
            connect_time = (time.time() - start_time) * 1000  # ms
            
            metrics["connectable"] = result == 0
            metrics["connect_time_ms"] = connect_time if result == 0 else None
            metrics["error_code"] = result if result != 0 else None
            
            # 如果连接成功，测试服务响应
            if result == 0:
                sock.send(b"HEAD /health HTTP/1.0\r\n\r\n")
                response_start = time.time()
                data = sock.recv(1024)
                response_time = (time.time() - response_start) * 1000
                
                metrics["response_time_ms"] = response_time
                metrics["response_data_size"] = len(data)
                
        except Exception as e:
            metrics["connectable"] = False
            metrics["error"] = str(e)
        finally:
            sock.close()
        
        return metrics
```

#### 1.3 文件系统监控

```python
class FilesystemMonitor:
    """文件系统监控器"""
    
    def monitor_filesystem(self, path: str) -> dict:
        """监控文件系统状态"""
        import os
        
        metrics = {
            "path": path,
            "timestamp": datetime.now().isoformat()
        }
        
        # 磁盘使用情况
        usage = psutil.disk_usage(path)
        metrics["disk_usage"] = {
            "total": usage.total,
            "used": usage.used,
            "free": usage.free,
            "percent": usage.percent
        }
        
        # inode 使用情况（Linux）
        if os.name != 'nt':
            import subprocess
            result = subprocess.run(
                ["df", "-i", path],
                capture_output=True,
                text=True
            )
            metrics["inode_info"] = result.stdout
        
        # 目录文件统计
        file_count = 0
        dir_count = 0
        total_size = 0
        
        for root, dirs, files in os.walk(path):
            dir_count += len(dirs)
            file_count += len(files)
            for file in files:
                try:
                    total_size += os.path.getsize(os.path.join(root, file))
                except:
                    pass
        
        metrics["file_stats"] = {
            "file_count": file_count,
            "dir_count": dir_count,
            "total_size": total_size
        }
        
        return metrics
```

---

### L2: 系统资源层（细粒度）

#### 2.1 CPU 细粒度监控

```python
class CPUDetailedMonitor:
    """CPU 详细监控器"""
    
    def collect_cpu_details(self) -> dict:
        """采集详细 CPU 指标"""
        cpu_times = psutil.cpu_times(percpu=True)
        cpu_percent = psutil.cpu_percent(percpu=True, interval=1)
        cpu_freq = psutil.cpu_freq(percpu=True)
        cpu_stats = psutil.cpu_stats()
        
        return {
            "timestamp": datetime.now().isoformat(),
            "overall": {
                "percent": psutil.cpu_percent(interval=1),
                "count": psutil.cpu_count(),
                "count_logical": psutil.cpu_count(logical=True)
            },
            "per_cpu": [
                {
                    "id": i,
                    "percent": cpu_percent[i] if isinstance(cpu_percent, list) else cpu_percent,
                    "user": cpu_times[i].user if isinstance(cpu_times, list) else cpu_times.user,
                    "system": cpu_times[i].system if isinstance(cpu_times, list) else cpu_times.system,
                    "idle": cpu_times[i].idle if isinstance(cpu_times, list) else cpu_times.idle,
                    "freq": {
                        "current": cpu_freq[i].current if isinstance(cpu_freq, list) else cpu_freq.current,
                        "min": cpu_freq[i].min if isinstance(cpu_freq, list) else cpu_freq.min,
                        "max": cpu_freq[i].max if isinstance(cpu_freq, list) else cpu_freq.max
                    } if cpu_freq else None
                }
                for i in range(psutil.cpu_count())
            ],
            "stats": {
                "ctx_switches": cpu_stats.ctx_switches,
                "interrupts": cpu_stats.interrupts,
                "soft_interrupts": cpu_stats.soft_interrupts,
                "syscalls": cpu_stats.syscalls
            },
            "load_average": os.getloadavg() if hasattr(os, 'getloadavg') else None
        }
```

#### 2.2 内存细粒度监控

```python
class MemoryDetailedMonitor:
    """内存详细监控器"""
    
    def collect_memory_details(self) -> dict:
        """采集详细内存指标"""
        virtual = psutil.virtual_memory()
        swap = psutil.swap_memory()
        
        # 内存分段信息（Linux）
        memory_segments = {}
        if os.path.exists('/proc/meminfo'):
            with open('/proc/meminfo', 'r') as f:
                for line in f:
                    if ':' in line:
                        key, value = line.split(':')
                        memory_segments[key.strip()] = value.strip()
        
        return {
            "timestamp": datetime.now().isoformat(),
            "virtual": {
                "total": virtual.total,
                "available": virtual.available,
                "percent": virtual.percent,
                "used": virtual.used,
                "free": virtual.free,
                "active": virtual.active,
                "inactive": virtual.inactive,
                "buffers": virtual.buffers,
                "cached": virtual.cached,
                "shared": virtual.shared
            },
            "swap": {
                "total": swap.total,
                "used": swap.used,
                "free": swap.free,
                "percent": swap.percent,
                "sin": swap.sin,  # 换入
                "sout": swap.sout  # 换出
            },
            "segments": memory_segments,
            "processes_top": self._get_top_memory_processes(10)
        }
    
    def _get_top_memory_processes(self, n: int) -> list:
        """获取内存占用最高的进程"""
        processes = []
        for proc in psutil.process_iter(['pid', 'name', 'memory_percent', 'memory_info']):
            try:
                processes.append({
                    "pid": proc.info['pid'],
                    "name": proc.info['name'],
                    "memory_percent": proc.info['memory_percent'],
                    "rss": proc.info['memory_info'].rss
                })
            except:
                pass
        
        return sorted(processes, key=lambda x: x['memory_percent'], reverse=True)[:n]
```

#### 2.3 GPU 监控（如有）

```python
class GPUMonitor:
    """GPU 监控器"""
    
    def collect_gpu_metrics(self) -> dict:
        """采集 GPU 指标"""
        try:
            import pynvml
            pynvml.nvmlInit()
            
            metrics = {
                "timestamp": datetime.now().isoformat(),
                "devices": []
            }
            
            device_count = pynvml.nvmlDeviceGetCount()
            for i in range(device_count):
                handle = pynvml.nvmlDeviceGetHandleByIndex(i)
                
                # 利用率
                utilization = pynvml.nvmlDeviceGetUtilizationRates(handle)
                
                # 内存信息
                memory = pynvml.nvmlDeviceGetMemoryInfo(handle)
                
                # 温度
                temperature = pynvml.nvmlDeviceGetTemperature(
                    handle, pynvml.NVML_TEMPERATURE_GPU
                )
                
                # 功耗
                power = pynvml.nvmlDeviceGetPowerUsage(handle)
                
                metrics["devices"].append({
                    "id": i,
                    "name": pynvml.nvmlDeviceGetName(handle).decode('utf-8'),
                    "utilization": {
                        "gpu": utilization.gpu,
                        "memory": utilization.memory
                    },
                    "memory": {
                        "total": memory.total,
                        "used": memory.used,
                        "free": memory.free,
                        "percent": (memory.used / memory.total) * 100
                    },
                    "temperature": temperature,
                    "power": {
                        "current": power / 1000,  # 转换为瓦特
                        "limit": pynvml.nvmlDeviceGetEnforcedPowerLimit(handle) / 1000
                    }
                })
            
            return metrics
            
        except ImportError:
            return {"error": "pynvml not installed", "timestamp": datetime.now().isoformat()}
        except Exception as e:
            return {"error": str(e), "timestamp": datetime.now().isoformat()}
```

---

### L3: 应用服务层（API级）

#### 3.1 API 详细监控

```python
class APIDetailedMonitor:
    """API 详细监控器"""
    
    def __init__(self):
        self.request_stats = {
            "total_requests": 0,
            "total_errors": 0,
            "response_times": [],
            "endpoint_stats": {}
        }
    
    def record_request(self, endpoint: str, method: str, status_code: int, response_time: float):
        """记录 API 请求"""
        self.request_stats["total_requests"] += 1
        
        if status_code >= 400:
            self.request_stats["total_errors"] += 1
        
        self.request_stats["response_times"].append(response_time)
        # 只保留最近1000个响应时间
        if len(self.request_stats["response_times"]) > 1000:
            self.request_stats["response_times"] = self.request_stats["response_times"][-1000:]
        
        # 端点统计
        key = f"{method} {endpoint}"
        if key not in self.request_stats["endpoint_stats"]:
            self.request_stats["endpoint_stats"][key] = {
                "count": 0,
                "errors": 0,
                "response_times": [],
                "status_codes": {}
            }
        
        stats = self.request_stats["endpoint_stats"][key]
        stats["count"] += 1
        if status_code >= 400:
            stats["errors"] += 1
        stats["response_times"].append(response_time)
        stats["status_codes"][status_code] = stats["status_codes"].get(status_code, 0) + 1
    
    def get_api_metrics(self) -> dict:
        """获取 API 指标"""
        response_times = self.request_stats["response_times"]
        
        if not response_times:
            return {"error": "No data available"}
        
        import statistics
        
        return {
            "timestamp": datetime.now().isoformat(),
            "overall": {
                "total_requests": self.request_stats["total_requests"],
                "total_errors": self.request_stats["total_errors"],
                "error_rate": (self.request_stats["total_errors"] / self.request_stats["total_requests"] * 100) if self.request_stats["total_requests"] > 0 else 0,
                "avg_response_time": statistics.mean(response_times),
                "min_response_time": min(response_times),
                "max_response_time": max(response_times),
                "p50_response_time": statistics.median(response_times),
                "p95_response_time": sorted(response_times)[int(len(response_times) * 0.95)],
                "p99_response_time": sorted(response_times)[int(len(response_times) * 0.99)]
            },
            "endpoints": {
                endpoint: {
                    "count": stats["count"],
                    "errors": stats["errors"],
                    "error_rate": (stats["errors"] / stats["count"] * 100) if stats["count"] > 0 else 0,
                    "avg_response_time": statistics.mean(stats["response_times"]) if stats["response_times"] else 0,
                    "status_codes": stats["status_codes"]
                }
                for endpoint, stats in self.request_stats["endpoint_stats"].items()
            }
        }
```

#### 3.2 数据库连接监控（如有）

```python
class DatabaseMonitor:
    """数据库连接监控器"""
    
    def monitor_database(self, connection_pool) -> dict:
        """监控数据库连接池"""
        return {
            "timestamp": datetime.now().isoformat(),
            "connection_pool": {
                "size": connection_pool.size(),
                "checked_in": connection_pool.checkedin(),
                "checked_out": connection_pool.checkedout(),
                "overflow": connection_pool.overflow(),
                "max_overflow": connection_pool.max_overflow()
            },
            "slow_queries": self._get_slow_queries(),
            "query_stats": self._get_query_stats()
        }
```

---

### L4: 业务功能层（功能级）

#### 4.1 视频处理监控

```python
class VideoProcessingMonitor:
    """视频处理监控器"""
    
    def __init__(self):
        self.processing_stats = {
            "total_frames": 0,
            "dropped_frames": 0,
            "processing_times": [],
            "fps_history": []
        }
    
    def record_frame_processing(self, processing_time: float, dropped: bool = False):
        """记录帧处理"""
        self.processing_stats["total_frames"] += 1
        if dropped:
            self.processing_stats["dropped_frames"] += 1
        self.processing_stats["processing_times"].append(processing_time)
        
        # 计算实时 FPS
        if len(self.processing_stats["processing_times"]) >= 30:
            avg_time = statistics.mean(self.processing_stats["processing_times"][-30:])
            fps = 1.0 / avg_time if avg_time > 0 else 0
            self.processing_stats["fps_history"].append(fps)
    
    def get_video_metrics(self) -> dict:
        """获取视频处理指标"""
        processing_times = self.processing_stats["processing_times"]
        
        return {
            "timestamp": datetime.now().isoformat(),
            "frames": {
                "total": self.processing_stats["total_frames"],
                "dropped": self.processing_stats["dropped_frames"],
                "drop_rate": (self.processing_stats["dropped_frames"] / self.processing_stats["total_frames"] * 100) if self.processing_stats["total_frames"] > 0 else 0
            },
            "performance": {
                "avg_processing_time": statistics.mean(processing_times) if processing_times else 0,
                "min_processing_time": min(processing_times) if processing_times else 0,
                "max_processing_time": max(processing_times) if processing_times else 0,
                "current_fps": self.processing_stats["fps_history"][-1] if self.processing_stats["fps_history"] else 0,
                "avg_fps": statistics.mean(self.processing_stats["fps_history"]) if self.processing_stats["fps_history"] else 0
            }
        }
```

#### 4.2 人脸合成监控

```python
class FaceSwapMonitor:
    """人脸合成监控器"""
    
    def monitor_face_swap(self, model_name: str, processing_time: float, success: bool, quality_score: float = None):
        """监控人脸合成"""
        return {
            "timestamp": datetime.now().isoformat(),
            "model": model_name,
            "processing_time_ms": processing_time * 1000,
            "success": success,
            "quality_score": quality_score,
            "model_load_time": self._get_model_load_time(model_name),
            "inference_time": self._get_inference_time()
        }
```

#### 4.3 音频处理监控

```python
class AudioProcessingMonitor:
    """音频处理监控器"""
    
    def monitor_audio_processing(self, effect_type: str, buffer_size: int, processing_time: float, latency: float):
        """监控音频处理"""
        return {
            "timestamp": datetime.now().isoformat(),
            "effect": effect_type,
            "buffer_size": buffer_size,
            "processing_time_ms": processing_time * 1000,
            "latency_ms": latency * 1000,
            "realtime_factor": processing_time / (buffer_size / 44100)  # 实时因子
        }
```

---

### L5: 用户体验层（体验级）

#### 5.1 GUI 响应监控

```python
class GUIExperienceMonitor:
    """GUI 用户体验监控器"""
    
    def __init__(self):
        self.interaction_times = []
        self.page_load_times = {}
    
    def record_interaction(self, action: str, start_time: float, end_time: float):
        """记录用户交互"""
        duration = (end_time - start_time) * 1000  # ms
        self.interaction_times.append({
            "action": action,
            "duration_ms": duration,
            "timestamp": datetime.now().isoformat()
        })
    
    def record_page_load(self, page: str, load_time: float):
        """记录页面加载时间"""
        if page not in self.page_load_times:
            self.page_load_times[page] = []
        self.page_load_times[page].append(load_time * 1000)  # ms
    
    def get_experience_metrics(self) -> dict:
        """获取用户体验指标"""
        recent_interactions = self.interaction_times[-100:]  # 最近100次交互
        
        return {
            "timestamp": datetime.now().isoformat(),
            "interactions": {
                "total": len(self.interaction_times),
                "recent_avg_response_time": statistics.mean([i["duration_ms"] for i in recent_interactions]) if recent_interactions else 0,
                "slow_interactions": len([i for i in recent_interactions if i["duration_ms"] > 1000])
            },
            "page_loads": {
                page: {
                    "avg_time": statistics.mean(times),
                    "max_time": max(times),
                    "min_time": min(times)
                }
                for page, times in self.page_load_times.items()
            }
        }
```

---

## 🔄 高频采集方案

### 采集频率设计

| 层级 | 指标类型 | 采集频率 | 保留时间 |
|------|----------|----------|----------|
| **L1 基础设施** | 进程状态、端口状态 | 5秒 | 24小时 |
| **L1 基础设施** | 文件系统、线程状态 | 30秒 | 7天 |
| **L2 系统资源** | CPU/内存/磁盘 | 10秒 | 7天 |
| **L2 系统资源** | 详细指标 | 60秒 | 30天 |
| **L3 应用服务** | API 指标 | 实时记录 | 7天 |
| **L3 应用服务** | 聚合统计 | 60秒 | 30天 |
| **L4 业务功能** | 帧处理、合成质量 | 实时记录 | 3天 |
| **L4 业务功能** | 性能统计 | 30秒 | 7天 |
| **L5 用户体验** | 交互响应 | 实时记录 | 3天 |
| **L5 用户体验** | 体验统计 | 5分钟 | 30天 |

### 采集器实现

```python
class HighFrequencyCollector:
    """高频采集器"""
    
    def __init__(self):
        self.collectors = {
            "process": ProcessMonitor(),
            "port": PortMonitor(),
            "cpu": CPUDetailedMonitor(),
            "memory": MemoryDetailedMonitor(),
            "api": APIDetailedMonitor(),
            "video": VideoProcessingMonitor(),
            "gui": GUIExperienceMonitor()
        }
        
        self.running = False
        self.threads = []
    
    def start_collection(self):
        """启动高频采集"""
        self.running = True
        
        # L1 基础设施层 - 5秒
        self._start_thread(self._collect_l1, 5)
        
        # L2 系统资源层 - 10秒
        self._start_thread(self._collect_l2, 10)
        
        # L3 应用服务层 - 实时（通过中间件）
        # L4 业务功能层 - 30秒
        self._start_thread(self._collect_l4, 30)
        
        # L5 用户体验层 - 5分钟
        self._start_thread(self._collect_l5, 300)
    
    def _start_thread(self, target, interval):
        """启动采集线程"""
        import threading
        
        def run():
            while self.running:
                try:
                    target()
                except Exception as e:
                    logger.error(f"采集错误: {e}")
                time.sleep(interval)
        
        thread = threading.Thread(target=run, daemon=True)
        thread.start()
        self.threads.append(thread)
    
    def _collect_l1(self):
        """采集 L1 指标"""
        for service in ["yl-monitor", "ar-backend", "user-gui"]:
            pid = self._get_service_pid(service)
            if pid:
                metrics = self.collectors["process"].collect_process_metrics(pid)
                self._store_metrics(f"l1.process.{service}", metrics)
    
    def _collect_l2(self):
        """采集 L2 指标"""
        cpu_metrics = self.collectors["cpu"].collect_cpu_details()
        memory_metrics = self.collectors["memory"].collect_memory_details()
        
        self._store_metrics("l2.cpu", cpu_metrics)
        self._store_metrics("l2.memory", memory_metrics)
    
    def _collect_l4(self):
        """采集 L4 指标"""
        video_metrics = self.collectors["video"].get_video_metrics()
        self._store_metrics("l4.video", video_metrics)
    
    def _collect_l5(self):
        """采集 L5 指标"""
        experience_metrics = self.collectors["gui"].get_experience_metrics()
        self._store_metrics("l5.experience", experience_metrics)
    
    def _store_metrics(self, key: str, metrics: dict):
        """存储指标"""
        # 存储到时间序列数据库（如 InfluxDB）或本地缓存
        timestamp = datetime.now().isoformat()
        # 实现存储逻辑...
        logger.debug(f"存储指标 {key}: {metrics}")
```

---

## 📊 监控面板增强

### 新增监控视图

#### 1. 实时性能监控视图

```javascript
// YL-monitor/static/js/realtime-monitor.js

class RealtimeMonitor {
    constructor() {
        this.charts = {};
        this.updateInterval = 5000; // 5秒更新
    }
    
    initCharts() {
        // CPU 使用率图表（每核）
        this.charts.cpu = new Chart(document.getElementById('cpu-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                title: {
                    display: true,
                    text: 'CPU 使用率（每核）'
                },
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            }
        });
        
        // 内存使用详情图表
        this.charts.memory = new Chart(document.getElementById('memory-chart'), {
            type: 'doughnut',
            data: {
                labels: ['已用', '缓存', '缓冲', '空闲'],
                datasets: [{
                    data: [0, 0, 0, 0],
                    backgroundColor: ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0']
                }]
            }
        });
        
        // API 响应时间分布
        this.charts.apiLatency = new Chart(document.getElementById('api-latency-chart'), {
            type: 'bar',
            data: {
                labels: ['p50', 'p95', 'p99', 'max'],
                datasets: [{
                    label: '响应时间 (ms)',
                    data: [0, 0, 0, 0],
                    backgroundColor: '#36a2eb'
                }]
            }
        });
        
        // 视频处理性能
        this.charts.video = new Chart(document.getElementById('video-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'FPS',
                        data: [],
                        borderColor: '#4bc0c0'
                    },
                    {
                        label: '丢帧率',
                        data: [],
                        borderColor: '#ff6384'
                    }
                ]
            }
        });
    }
    
    async updateData() {
        // 获取最新指标
        const response = await fetch('/api/v1/monitor/detailed-metrics');
        const data = await response.json();
        
        // 更新 CPU 图表
        this.updateCPUChart(data.l2.cpu);
        
        // 更新内存图表
        this.updateMemoryChart(data.l2.memory);
        
        // 更新 API 图表
        this.updateAPIChart(data.l3.api);
        
        // 更新视频图表
        this.updateVideoChart(data.l4.video);
    }
    
    updateCPUChart(cpuData) {
        const labels = cpuData.per_cpu.map(c => `CPU ${c.id}`);
        const data = cpuData.per_cpu.map(c => c.percent);
        
        this.charts.cpu.data.labels = labels;
        this.charts.cpu.data.datasets = [{
            label: '使用率 %',
            data: data,
            backgroundColor: data.map(v => v > 80 ? '#ff6384' : '#36a2eb')
        }];
        this.charts.cpu.update();
    }
    
    start() {
        this.initCharts();
        this.updateData();
        setInterval(() => this.updateData(), this.updateInterval);
    }
}
```

#### 2. 告警规则增强

```python
# YL-monitor/app/services/advanced_alerts.py

class AdvancedAlertRules:
    """高级告警规则"""
    
    RULES = {
        # L1 基础设施层告警
        "process_zombie": {
            "level": "critical",
            "condition": lambda m: m.get("status") == "zombie",
            "message": "进程进入僵尸状态: {name} (PID: {pid})"
        },
        "high_fd_usage": {
            "level": "warning",
            "condition": lambda m: m.get("num_fds", 0) > 1000,
            "message": "进程文件描述符过多: {num_fds} (PID: {pid})"
        },
        "port_slow": {
            "level": "warning",
            "condition": lambda m: m.get("connect_time_ms", 0) > 500,
            "message": "端口连接缓慢: {host}:{port} ({connect_time_ms}ms)"
        },
        
        # L2 系统资源层告警
        "cpu_steal_time": {
            "level": "warning",
            "condition": lambda m: m.get("steal", 0) > 10,
            "message": "CPU steal time 过高: {steal}% (可能存在资源争抢)"
        },
        "memory_pressure": {
            "level": "critical",
            "condition": lambda m: m.get("available", 0) < 500 * 1024 * 1024,  # < 500MB
            "message": "内存严重不足: 可用 {available}MB"
        },
        "swap_high": {
            "level": "warning",
            "condition": lambda m: m.get("percent", 0) > 50,
            "message": "Swap 使用率过高: {percent}%"
        },
        
        # L3 应用服务层告警
        "api_error_rate": {
            "level": "critical",
            "condition": lambda m: m.get("overall", {}).get("error_rate", 0) > 5,
            "message": "API 错误率过高: {error_rate}%"
        },
        "api_latency_p99": {
            "level": "warning",
            "condition": lambda m: m.get("overall", {}).get("p99_response_time", 0) > 1000,
            "message": "API P99 响应时间过长: {p99_response_time}ms"
        },
        
        # L4 业务功能层告警
        "video_drop_rate": {
            "level": "warning",
            "condition": lambda m: m.get("frames", {}).get("drop_rate", 0) > 5,
            "message": "视频丢帧率过高: {drop_rate}%"
        },
        "video_low_fps": {
            "level": "warning",
            "condition": lambda m: m.get("performance", {}).get("current_fps", 0) < 15,
            "message": "视频帧率过低: {current_fps} FPS"
        },
        
        # L5 用户体验层告警
        "gui_slow_interaction": {
            "level": "warning",
            "condition": lambda m: m.get("interactions", {}).get("slow_interactions", 0) > 10,
            "message": "GUI 交互响应缓慢次数: {slow_interactions}"
        },
        "gui_high_load_time": {
            "level": "warning",
            "condition": lambda m: any(
                stats.get("avg_time", 0) > 3000 
                for stats in m.get("page_loads", {}).values()
            ),
            "message": "页面加载时间过长"
        }
    }
    
    def evaluate_rules(self, metrics: dict) -> list:
        """评估所有告警规则"""
        alerts = []
        
        for rule_name, rule in self.RULES.items():
            try:
                if rule["condition"](metrics):
                    alert = {
                        "rule": rule_name,
                        "level": rule["level"],
                        "message": rule["message"].format(**metrics),
                        "timestamp": datetime.now().isoformat(),
                        "metrics": metrics
                    }
                    alerts.append(alert)
            except Exception as e:
                logger.error(f"评估规则 {rule_name} 失败: {e}")
        
        return alerts
```

---

## 🎯 实施路线图

### 阶段1: 基础设施层细化（1-2天）

- [ ] 实现 ProcessMonitor 进程级监控
- [ ] 实现 PortMonitor 端口级监控
- [ ] 实现 FilesystemMonitor 文件系统监控
- [ ] 集成到 YL-monitor 采集器
- [ ] 更新监控面板显示进程详情

### 阶段2: 系统资源层细化（1-2天）

- [ ] 实现 CPUDetailedMonitor 详细CPU监控
- [ ] 实现 MemoryDetailedMonitor 详细内存监控
- [ ] 实现 GPUMonitor GPU监控（如有）
- [ ] 添加系统资源历史趋势图
- [ ] 实现资源使用预测（可选）

### 阶段3: 应用服务层细化（2-3天）

- [ ] 实现 APIDetailedMonitor API详细监控
- [ ] 添加 API 中间件自动记录
- [ ] 实现 DatabaseMonitor 数据库监控（如有）
- [ ] 添加 API 性能分析视图
- [ ] 实现慢查询自动检测

### 阶段4: 业务功能层细化（2-3天）

- [ ] 实现 VideoProcessingMonitor 视频处理监控
- [ ] 实现 FaceSwapMonitor 人脸合成监控
- [ ] 实现 AudioProcessingMonitor 音频处理监控
- [ ] 添加业务质量评分
- [ ] 实现性能瓶颈自动定位

### 阶段5: 用户体验层细化（1-2天）

- [ ] 实现 GUIExperienceMonitor 用户体验监控
- [ ] 添加 GUI 性能埋点
- [ ] 实现用户操作路径分析
- [ ] 添加体验评分仪表板

### 阶段6: 高频采集与告警（2-3天）

- [ ] 实现 HighFrequencyCollector 高频采集器
- [ ] 配置采集频率和保留策略
- [ ] 实现 AdvancedAlertRules 高级告警
- [ ] 配置告警通知渠道
- [ ] 实现告警抑制和聚合

---

## 📈 预期收益

| 优化项 | 当前状态 | 优化后 | 收益 |
|--------|----------|--------|------|
| **监控粒度** | 服务级（30-60秒） | 进程级（5秒）+ 功能级（实时） | 问题发现时间从分钟级降至秒级 |
| **指标维度** | 10+ 基础指标 | 100+ 细粒度指标 | 全面掌握系统状态 |
| **告警精度** | 服务宕机告警 | 性能劣化预警 + 趋势预测 | 从事后处理转向事前预防 |
| **故障定位** | 人工排查（10-30分钟） | 自动定位（1-3分钟） | 故障恢复时间缩短 80% |
| **用户体验** | 被动响应投诉 | 主动监控体验指标 | 用户满意度提升 |

---

## 🎉 总结

### 核心优化点

1. **五层监控架构**: 从基础设施到用户体验的全栈监控
2. **高频采集**: 5秒级采集频率，捕捉瞬时异常
3. **细粒度指标**: 100+ 指标覆盖所有层级
4. **智能告警**: 从简单阈值到多维度关联分析
5. **可视化增强**: 实时监控面板，直观展示系统状态

### 实施建议

**优先级排序**:
1. **高优先级**: L1 基础设施层 + L2 系统资源层（基础保障）
2. **中优先级**: L3 应用服务层 + L4 业务功能层（性能优化）
3. **低优先级**: L5 用户体验层（体验提升）

**风险控制**:
- 高频采集可能增加系统负载，建议先在小范围测试
- 大量指标需要合理的存储和清理策略
- 告警规则需要逐步调优，避免告警风暴

### 下一步行动

1. **评估当前监控现状**，确定优化重点
2. **制定详细实施计划**，分阶段推进
3. **搭建测试环境**，验证优化效果
4. **逐步上线**，持续监控和调优

---

**文档版本:** 1.0.0  
**创建日期:** 2026-02-16  
**维护者:** YL-AR-DGN 项目团队

**关联文档**:
- [监控整合方案](./3.监控整合方案.md)
- [统一监控面板架构方案](./统一监控面板架构方案.md)
- [完成报告-阶段1到阶段3](./完成报告-阶段1到阶段3.md)
