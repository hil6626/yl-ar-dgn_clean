# 部署任务6.3: AR-backend音频处理功能验证

**任务ID:** 6.3  
**所属阶段:** 阶段6 - 核心业务功能验证  
**任务名称:** AR-backend音频处理功能验证  
**优先级:** P0（最高优先级）  
**关键性:** 阻塞性  
**预计工时:** 4小时  
**负责人:** 音频处理工程师  
**前置依赖:** 无  
**状态:** 待开始

---

## 一、任务目标

验证AR-backend音频处理功能，确保音频捕获、音高调整、混响效果、变速处理和实时处理功能正常。

---

## 二、工作内容

1. 音频捕获功能测试
2. 音高调整效果测试
3. 混响效果测试
4. 变速处理测试
5. 相位效果测试

---

## 三、实施步骤

### 步骤1: 检查音频设备

```bash
# 1. 列出录音设备
echo "录音设备列表:"
arecord -l 2>/dev/null || echo "arecord未安装，尝试安装alsa-utils"

# 2. 列出播放设备
echo -e "\n播放设备列表:"
aplay -l 2>/dev/null || echo "aplay未安装"

# 3. 检查PulseAudio
echo -e "\nPulseAudio状态:"
pactl info 2>/dev/null || echo "PulseAudio未运行"

# 4. 检查PyAudio
python3 -c "
import pyaudio
p = pyaudio.PyAudio()
print(f'PyAudio版本: {pyaudio.get_portaudio_version_text()}')
print(f'音频设备数量: {p.get_device_count()}')
print('\\n设备列表:')
for i in range(p.get_device_count()):
    info = p.get_device_info_by_index(i)
    print(f'  {i}: {info[\"name\"]} (输入: {info[\"maxInputChannels\"]}, 输出: {info[\"maxOutputChannels\"]})')
p.terminate()
" 2>/dev/null || echo "PyAudio未安装"
```

### 步骤2: 测试音频捕获

```bash
# 创建音频捕获测试脚本
cat > /tmp/test_audio_capture.py << 'EOF'
#!/usr/bin/env python3
import pyaudio
import wave
import sys
import time

def test_audio_capture():
    print("=" * 50)
    print("音频捕获功能测试")
    print("=" * 50)
    
    # 初始化PyAudio
    try:
        p = pyaudio.PyAudio()
        print("✓ PyAudio初始化成功")
    except Exception as e:
        print(f"✗ PyAudio初始化失败: {e}")
        return False
    
    # 查找输入设备
    input_device = None
    for i in range(p.get_device_count()):
        info = p.get_device_info_by_index(i)
        if info['maxInputChannels'] > 0:
            input_device = i
            print(f"✓ 找到输入设备: {info['name']} (索引: {i})")
            break
    
    if input_device is None:
        print("✗ 未找到音频输入设备")
        return False
    
    # 音频参数
    CHUNK = 1024
    FORMAT = pyaudio.paInt16
    CHANNELS = 1
    RATE = 44100
    RECORD_SECONDS = 5
    
    print(f"\n开始录制 {RECORD_SECONDS} 秒音频...")
    
    try:
        # 打开音频流
        stream = p.open(
            format=FORMAT,
            channels=CHANNELS,
            rate=RATE,
            input=True,
            input_device_index=input_device,
            frames_per_buffer=CHUNK
        )
        
        print("✓ 音频流已打开")
        
        # 录制音频
        frames = []
        start_time = time.time()
        
        for i in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
            data = stream.read(CHUNK, exception_on_overflow=False)
            frames.append(data)
            
            if i % 43 == 0:  # 约每秒更新一次
                elapsed = time.time() - start_time
                print(f"  录制中... {elapsed:.1f}s")
        
        print("✓ 录制完成")
        
        # 关闭流
        stream.stop_stream()
        stream.close()
        
        # 保存测试文件
        output_file = "/tmp/test_capture.wav"
        wf = wave.open(output_file, 'wb')
        wf.setnchannels(CHANNELS)
        wf.setsampwidth(p.get_sample_size(FORMAT))
        wf.setframerate(RATE)
        wf.writeframes(b''.join(frames))
        wf.close()
        
        print(f"✓ 音频已保存: {output_file}")
        
        # 验证文件
        import os
        file_size = os.path.getsize(output_file)
        print(f"  文件大小: {file_size} bytes")
        
        # 计算录制时长
        actual_duration = len(frames) * CHUNK / RATE
        expected_duration = RECORD_SECONDS
        duration_diff = abs(actual_duration - expected_duration)
        
        print(f"\n" + "=" * 50)
        print("音频捕获结果:")
        print(f"  预期时长: {expected_duration}s")
        print(f"  实际时长: {actual_duration:.2f}s")
        print(f"  时长差异: {duration_diff:.2f}s")
        print(f"  采样率: {RATE}Hz")
        print(f"  声道数: {CHANNELS}")
        print("=" * 50)
        
        p.terminate()
        
        # 验证结果
        success = duration_diff < 0.5  # 差异小于0.5秒
        
        if success:
            print("✓ 音频捕获测试通过")
        else:
            print("✗ 音频捕获测试失败")
            print("  - 录制时长差异过大")
        
        return success
        
    except Exception as e:
        print(f"✗ 音频捕获错误: {e}")
        p.terminate()
        return False

if __name__ == "__main__":
    success = test_audio_capture()
    sys.exit(0 if success else 1)
EOF

# 执行测试
python3 /tmp/test_audio_capture.py
```

### 步骤3: 测试音频效果

```bash
# 创建音频效果测试脚本
cat > /tmp/test_audio_effects.py << 'EOF'
#!/usr/bin/env python3
import sys
import numpy as np
import time

sys.path.insert(0, '/home/vboxuser/桌面/项目部署/项目1/yl-ar-dgn_clean/AR-backend')

def test_pitch_shift():
    """测试音高调整"""
    print("\n" + "=" * 50)
    print("音高调整效果测试")
    print("=" * 50)
    
    try:
        from app.core.audio_effects import PitchShifter
        shifter = PitchShifter()
        print("✓ 音高调整器初始化成功")
    except Exception as e:
        print(f"✗ 初始化失败: {e}")
        return False
    
    # 生成测试音频 (1秒，440Hz正弦波)
    sample_rate = 44100
    duration = 1.0
    t = np.linspace(0, duration, int(sample_rate * duration))
    audio = np.sin(2 * np.pi * 440 * t).astype(np.float32)
    
    # 测试不同音高调整
    pitch_values = [0.5, 1.0, 1.5, 2.0]
    processing_times = []
    
    for pitch in pitch_values:
        start = time.time()
        result = shifter.shift(audio, sample_rate, pitch)
        end = time.time()
        
        processing_times.append((end - start) * 1000)
        
        if result is not None:
            print(f"✓ 音高 {pitch}x: 处理成功")
        else:
            print(f"✗ 音高 {pitch}x: 处理失败")
    
    avg_time = np.mean(processing_times)
    print(f"\n平均处理时间: {avg_time:.2f}ms")
    
    success = avg_time < 50  # 处理时间<50ms
    if success:
        print("✓ 音高调整测试通过")
    else:
        print("✗ 音高调整测试失败")
    
    return success

def test_reverb():
    """测试混响效果"""
    print("\n" + "=" * 50)
    print("混响效果测试")
    print("=" * 50)
    
    try:
        from app.core.audio_effects import ReverbEffect
        reverb = ReverbEffect()
        print("✓ 混响效果器初始化成功")
    except Exception as e:
        print(f"✗ 初始化失败: {e}")
        return False
    
    # 生成测试音频
    sample_rate = 44100
    duration = 1.0
    t = np.linspace(0, duration, int(sample_rate * duration))
    audio = np.sin(2 * np.pi * 440 * t).astype(np.float32)
    
    # 测试不同混响强度
    reverb_values = [0.0, 0.3, 0.6, 0.9]
    
    for intensity in reverb_values:
        result = reverb.apply(audio, sample_rate, intensity)
        
        if result is not None:
            # 检查音频长度变化（混响应该增加长度）
            print(f"✓ 混响强度 {intensity}: 处理成功")
        else:
            print(f"✗ 混响强度 {intensity}: 处理失败")
    
    print("✓ 混响效果测试通过")
    return True

def test_speed_change():
    """测试变速处理"""
    print("\n" + "=" * 50)
    print("变速处理测试")
    print("=" * 50)
    
    try:
        from app.core.audio_effects import SpeedChanger
        changer = SpeedChanger()
        print("✓ 变速处理器初始化成功")
    except Exception as e:
        print(f"✗ 初始化失败: {e}")
        return False
    
    # 生成测试音频
    sample_rate = 44100
    duration = 1.0
    t = np.linspace(0, duration, int(sample_rate * duration))
    audio = np.sin(2 * np.pi * 440 * t).astype(np.float32)
    
    # 测试不同速度
    speed_values = [0.5, 1.0, 1.5, 2.0]
    
    for speed in speed_values:
        result = changer.change_speed(audio, speed)
        
        if result is not None:
            expected_length = len(audio) / speed
            actual_length = len(result)
            length_diff = abs(actual_length - expected_length) / expected_length
            
            if length_diff < 0.1:  # 长度差异<10%
                print(f"✓ 速度 {speed}x: 处理成功")
            else:
                print(f"⚠ 速度 {speed}x: 长度不匹配")
        else:
            print(f"✗ 速度 {speed}x: 处理失败")
    
    print("✓ 变速处理测试通过")
    return True

if __name__ == "__main__":
    results = []
    results.append(test_pitch_shift())
    results.append(test_reverb())
    results.append(test_speed_change())
    
    print("\n" + "=" * 50)
    print("音频效果测试总结")
    print("=" * 50)
    print(f"音高调整: {'✓ 通过' if results[0] else '✗ 失败'}")
    print(f"混响效果: {'✓ 通过' if results[1] else '✗ 失败'}")
    print(f"变速处理: {'✓ 通过' if results[2] else '✗ 失败'}")
    
    sys.exit(0 if all(results) else 1)
EOF

# 执行测试
python3 /tmp/test_audio_effects.py
```

### 步骤4: 测试实时音频处理

```bash
# 创建实时音频处理测试脚本
cat > /tmp/test_realtime_audio.py << 'EOF'
#!/usr/bin/env python3
import pyaudio
import numpy as np
import sys
import time
import threading

sys.path.insert(0, '/home/vboxuser/桌面/项目部署/项目1/yl-ar-dgn_clean/AR-backend')

def test_realtime_processing():
    print("=" * 50)
    print("实时音频处理测试")
    print("=" * 50)
    
    try:
        from app.core.audio_effects import AudioEffectsChain
        effects = AudioEffectsChain()
        print("✓ 音频效果链初始化成功")
    except Exception as e:
        print(f"✗ 初始化失败: {e}")
        return False
    
    # 音频参数
    CHUNK = 1024
    FORMAT = pyaudio.paInt16
    CHANNELS = 1
    RATE = 44100
    
    p = pyaudio.PyAudio()
    
    # 查找输入输出设备
    input_device = None
    output_device = None
    
    for i in range(p.get_device_count()):
        info = p.get_device_info_by_index(i)
        if info['maxInputChannels'] > 0 and input_device is None:
            input_device = i
        if info['maxOutputChannels'] > 0 and output_device is None:
            output_device = i
    
    if input_device is None or output_device is None:
        print("✗ 未找到音频设备")
        return False
    
    print(f"✓ 输入设备: {input_device}")
    print(f"✓ 输出设备: {output_device}")
    
    # 打开输入流
    input_stream = p.open(
        format=FORMAT,
        channels=CHANNELS,
        rate=RATE,
        input=True,
        input_device_index=input_device,
        frames_per_buffer=CHUNK
    )
    
    # 打开输出流
    output_stream = p.open(
        format=FORMAT,
        channels=CHANNELS,
        rate=RATE,
        output=True,
        output_device_index=output_device,
        frames_per_buffer=CHUNK
    )
    
    print("✓ 音频流已打开")
    print("\n开始实时处理测试 (5秒)...")
    print("请对着麦克风说话...")
    
    # 测试参数
    test_duration = 5
    start_time = time.time()
    frame_count = 0
    processing_times = []
    
    try:
        while time.time() - start_time < test_duration:
            # 读取音频数据
            data = input_stream.read(CHUNK, exception_on_overflow=False)
            
            # 转换为numpy数组
            audio_data = np.frombuffer(data, dtype=np.int16)
            
            # 应用效果
            process_start = time.time()
            processed = effects.process(audio_data, RATE)
            process_end = time.time()
            
            processing_times.append((process_end - process_start) * 1000)
            
            # 播放处理后的音频
            output_stream.write(processed.astype(np.int16).tobytes())
            
            frame_count += 1
            
            if frame_count % 10 == 0:
                print(f"  已处理 {frame_count} 块")
        
        print("✓ 实时处理完成")
        
    except KeyboardInterrupt:
        print("\n测试被中断")
    
    # 关闭流
    input_stream.stop_stream()
    input_stream.close()
    output_stream.stop_stream()
    output_stream.close()
    p.terminate()
    
    # 计算统计信息
    if processing_times:
        import statistics
        avg_time = statistics.mean(processing_times)
        max_time = max(processing_times)
        
        print(f"\n" + "=" * 50)
        print("实时处理结果:")
        print(f"  处理块数: {frame_count}")
        print(f"  平均处理时间: {avg_time:.2f}ms")
        print(f"  最大处理时间: {max_time:.2f}ms")
        print("=" * 50)
        
        # 验证结果
        success = avg_time < 23  # 1024样本@44100Hz = 23ms
        
        if success:
            print("✓ 实时音频处理测试通过")
        else:
            print("✗ 实时音频处理测试失败")
            print("  - 处理延迟过高")
        
        return success
    else:
        print("✗ 没有处理数据")
        return False

if __name__ == "__main__":
    success = test_realtime_processing()
    sys.exit(0 if success else 1)
EOF

# 执行测试
python3 /tmp/test_realtime_audio.py
```

---

## 四、验证步骤

### 验证清单

- [ ] 音频设备检测成功
- [ ] PyAudio初始化成功
- [ ] 音频捕获延迟<50ms
- [ ] 音高调整自然，无失真
- [ ] 混响效果可调，无明显回声
- [ ] 变速处理保持音调
- [ ] 实时处理CPU占用<20%

### 验证命令

```bash
# 快速验证脚本
cat > /tmp/verify_task_6.3.sh << 'EOF'
#!/bin/bash
echo "========================================"
echo "任务6.3验证: AR-backend音频处理"
echo "========================================"

errors=0

# 1. 检查PyAudio
echo -n "检查PyAudio... "
if python3 -c "import pyaudio; print(pyaudio.get_portaudio_version_text())" 2>/dev/null; then
    echo "✓ 通过"
else
    echo "✗ 失败"
    errors=$((errors + 1))
fi

# 2. 检查音频设备
echo -n "检查音频设备... "
device_count=$(python3 -c "
import pyaudio
p = pyaudio.PyAudio()
print(p.get_device_count())
p.terminate()
" 2>/dev/null)

if [ "$device_count" -gt 0 ] 2>/dev/null; then
    echo "✓ 通过 (找到 $device_count 个设备)"
else
    echo "✗ 失败"
    errors=$((errors + 1))
fi

echo "========================================"
if [ $errors -eq 0 ]; then
    echo "✓ 任务6.3基础验证通过"
    exit 0
else
    echo "✗ 任务6.3验证失败 ($errors 个错误)"
    exit 1
fi
EOF

chmod +x /tmp/verify_task_6.3.sh
/tmp/verify_task_6.3.sh
```

---

## 五、预期结果

### 成功标准

| 指标 | 目标值 | 验证方法 |
|------|--------|----------|
| 音频捕获延迟 | <50ms | 实时测试 |
| 音高调整质量 | 自然无失真 | 听觉测试 |
| 混响效果 | 可调范围0-1 | 功能测试 |
| 变速处理 | 保持音调 | 质量测试 |
| 实时处理延迟 | <23ms | 性能测试 |
| CPU占用 | <20% | 资源监控 |

### 交付物

- [ ] 音频捕获测试报告
- [ ] 音频效果测试报告
- [ ] 实时处理性能报告
- [ ] 验证通过标记

---

## 六、可能产生的问题及解决方案

| 问题 | 风险等级 | 产生原因 | 解决方式 | 预防方式 |
|------|----------|----------|----------|----------|
| 音频设备无法打开 | 高 | 权限或设备占用 | 1. 检查ALSA/PulseAudio<br>2. 释放占用设备<br>3. 使用备用设备 | 1. 音频设备检测脚本<br>2. 权限配置文档 |
| 音频延迟高 | 高 | 缓冲区设置或处理慢 | 1. 减小缓冲区<br>2. 优化处理算法<br>3. 使用低延迟模式 | 1. 延迟基准测试<br>2. 自动优化配置 |
| 音质损失 | 中 | 重采样或压缩 | 1. 使用高质量重采样<br>2. 调整比特率<br>3. 无损处理 | 1. 音质评估工具<br>2. 参数推荐 |
| 效果不明显 | 低 | 参数设置或算法问题 | 1. 调整参数范围<br>2. 更换算法实现<br>3. 预处理增强 | 1. 效果预览功能 |

---

## 七、执行检查点

- [ ] 音频捕获测试通过
- [ ] 音高调整测试通过
- [ ] 混响效果测试通过
- [ ] 变速处理测试通过
- [ ] 实时处理性能达标

---

## 八、关联文档

- [任务跟踪-阶段6-核心业务功能验证.md](./任务跟踪-阶段6-核心业务功能验证.md)
- [任务跟踪-阶段6-核心业务功能验证-部署任务6.2-AR-backend人脸合成功能验证.md](./任务跟踪-阶段6-核心业务功能验证-部署任务6.2-AR-backend人脸合成功能验证.md)
- [任务跟踪-阶段6-核心业务功能验证-部署任务6.4-AR-backend虚拟摄像头验证.md](./任务跟踪-阶段6-核心业务功能验证-部署任务6.4-AR-backend虚拟摄像头验证.md)

---

**创建时间:** 2026-02-11  
**最后更新:** 2026-02-11
