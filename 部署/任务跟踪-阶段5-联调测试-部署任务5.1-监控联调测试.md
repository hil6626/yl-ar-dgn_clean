# Phase 5 - Task 5.1: Monitoring Integration Testing - Detailed Deployment Document

**Task ID:** 5.1  
**Task Name:** Monitoring Integration Testing  
**Priority:** P0 (Blocking)  
**Estimated Hours:** 3 hours  
**Status:** Pending  
**Prerequisites:** Phases 1-4 completed

---

## I. Task Objectives

Test the integration between YL-monitor and all components (AR-backend, User GUI) to ensure monitoring works correctly.

## II. Test Scenarios

### 2.1 Test Coverage

| Scenario | Component | Test Type | Expected Result |
|----------|-----------|-----------|-----------------|
| Health check | All | API | Returns 200 OK |
| Heartbeat | All | API | Received every 30s |
| Metrics collection | All | Data | Metrics stored |
| Alert generation | All | Event | Alerts triggered |
| Dashboard display | YL-monitor | UI | All nodes visible |

## III. Deployment Content

### 3.1 Monitoring Test Script

#### File: test/integration/test_monitoring.py

```python
#!/usr/bin/env python3
"""
Monitoring Integration Tests
"""

import unittest
import requests
import time
import json
from datetime import datetime
from pathlib import Path


class TestMonitoringIntegration(unittest.TestCase):
    """
    Test monitoring integration
    """

    BASE_URL = "http://localhost:5500"
    AR_BACKEND_URL = "http://localhost:5501"
    USER_GUI_URL = "http://localhost:5502"

    def test_yl_monitor_health(self):
        """Test YL-monitor health endpoint"""
        try:
            response = requests.get(
                f"{self.BASE_URL}/api/health",
                timeout=5
            )
            self.assertEqual(response.status_code, 200)
            data = response.json()
            self.assertEqual(data.get('status'), 'healthy')
        except requests.RequestException as e:
            self.fail(f"YL-monitor health check failed: {e}")

    def test_ar_backend_health(self):
        """Test AR-backend health endpoint"""
        try:
            response = requests.get(
                f"{self.AR_BACKEND_URL}/health",
                timeout=5
            )
            self.assertIn(response.status_code, [200, 404])  # 404 if not implemented yet
        except requests.RequestException:
            self.skipTest("AR-backend not accessible")

    def test_user_gui_health(self):
        """Test User GUI health endpoint"""
        try:
            response = requests.get(
                f"{self.USER_GUI_URL}/health",
                timeout=5
            )
            self.assertIn(response.status_code, [200, 404])
        except requests.RequestException:
            self.skipTest("User GUI not accessible")

    def test_monitoring_summary(self):
        """Test monitoring summary API"""
        try:
            response = requests.get(
                f"{self.BASE_URL}/api/summary",
                timeout=5
            )
            self.assertEqual(response.status_code, 200)
            data = response.json()
            self.assertIn('status', data)
            self.assertIn('services', data)
        except requests.RequestException as e:
            self.fail(f"Summary API failed: {e}")

    def test_ar_nodes_api(self):
        """Test AR nodes API"""
        try:
            response = requests.get(
                f"{self.BASE_URL}/api/v1/ar/nodes",
                timeout=5
            )
            self.assertEqual(response.status_code, 200)
            data = response.json()
            # Should return nodes data
            self.assertIsInstance(data, (dict, list))
        except requests.RequestException as e:
            self.skipTest(f"AR nodes API not available: {e}")

    def test_heartbeat_simulation(self):
        """Simulate component heartbeat"""
        heartbeat_data = {
            "node_id": "test-node-1",
            "status": "online",
            "timestamp": datetime.utcnow().isoformat(),
            "metrics": {
                "cpu_percent": 25.5,
                "memory_percent": 40.0
            }
        }

        try:
            response = requests.post(
                f"{self.BASE_URL}/api/v1/ar/heartbeat",
                json=heartbeat_data,
                timeout=5
            )
            # Should accept heartbeat
            self.assertIn(response.status_code, [200, 201, 404])
        except requests.RequestException as e:
            self.skipTest(f"Heartbeat API not available: {e}")

    def test_dashboard_accessible(self):
        """Test monitoring dashboard is accessible"""
        try:
            response = requests.get(
                self.BASE_URL,
                timeout=5
            )
            self.assertEqual(response.status_code, 200)
            # Should return HTML
            self.assertIn('text/html', response.headers.get('content-type', ''))
        except requests.RequestException as e:
            self.fail(f"Dashboard not accessible: {e}")

    def test_metrics_endpoint(self):
        """Test metrics endpoint"""
        try:
            response = requests.get(
                f"{self.BASE_URL}/metrics",
                timeout=5
            )
            # May return metrics or 404 if not enabled
            self.assertIn(response.status_code, [200, 404])
        except requests.RequestException:
            self.skipTest("Metrics endpoint not available")


class TestMonitoringDataFlow(unittest.TestCase):
    """
    Test data flow between components and monitor
    """

    def test_data_collection_interval(self):
        """Test that data is collected at expected intervals"""
        # This would test that metrics are collected every 30 seconds
        # Implementation depends on actual monitoring setup
        pass

    def test_alert_generation(self):
        """Test alert generation for failures"""
        # Simulate a failure condition
        # Verify alert is generated
        pass


def run_monitoring_tests():
    """Run all monitoring tests"""
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()

    suite.addTests(loader.loadTestsFromTestCase(TestMonitoringIntegration))
    suite.addTests(loader.loadTestsFromTestCase(TestMonitoringDataFlow))

    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    return result.wasSuccessful()


if __name__ == '__main__':
    success = run_monitoring_tests()
    exit(0 if success else 1)
```

### 3.2 Monitoring Test Runner

#### File: test/integration/run_monitoring_tests.sh

```bash
#!/bin/bash
# Run Monitoring Integration Tests

set -e

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
LOG_FILE="$PROJECT_ROOT/logs/monitoring_tests_$(date +%Y%m%d_%H%M%S).log"

mkdir -p "$(dirname "$LOG_FILE")"

echo "========================================"
echo "Monitoring Integration Tests"
echo "Started: $(date)"
echo "========================================"

# Check if services are running
echo ""
echo "Checking service status..."

check_service() {
    local name=$1
    local url=$2
    
    if curl -s "$url" > /dev/null 2>&1; then
        echo "  ✓ $name is running"
        return 0
    else
        echo "  ✗ $name is not accessible"
        return 1
    fi
}

YL_MONITOR_OK=false
AR_BACKEND_OK=false
USER_GUI_OK=false

if check_service "YL-monitor" "http://localhost:5500/api/health"; then
    YL_MONITOR_OK=true
fi

if check_service "AR-backend" "http://localhost:5501/health"; then
    AR_BACKEND_OK=true
fi

if check_service "User GUI" "http://localhost:5502/health"; then
    USER_GUI_OK=true
fi

# Run Python tests
echo ""
echo "Running Python integration tests..."

cd "$PROJECT_ROOT"
if python3 test/integration/test_monitoring.py 2>&1 | tee -a "$LOG_FILE"; then
    echo ""
    echo "✓ All monitoring tests passed"
    TEST_RESULT=0
else
    echo ""
    echo "✗ Some monitoring tests failed"
    TEST_RESULT=1
fi

# Generate report
echo ""
echo "========================================"
echo "Test Report"
echo "========================================"
echo "YL-monitor: $([ "$YL_MONITOR_OK" = true ] && echo 'OK' || echo 'FAIL')"
echo "AR-backend: $([ "$AR_BACKEND_OK" = true ] && echo 'OK' || echo 'FAIL')"
echo "User GUI: $([ "$USER_GUI_OK" = true ] && echo 'OK' || echo 'FAIL')"
echo "Log file: $LOG_FILE"

exit $TEST_RESULT
```

## IV. Deployment Steps

```bash
# 1. Create test directory
mkdir -p test/integration

# 2. Create monitoring test
# Edit test/integration/test_monitoring.py

# 3. Create test runner
# Edit test/integration/run_monitoring_tests.sh

# 4. Make executable
chmod +x test/integration/run_monitoring_tests.sh

# 5. Run tests
./test/integration/run_monitoring_tests.sh
```

## V. Verification Checklist

- [ ] Monitoring test created
- [ ] Test runner created
- [ ] YL-monitor health check passes
- [ ] AR-backend monitoring works
- [ ] User GUI monitoring works
- [ ] Dashboard accessible
- [ ] All tests pass

## VI. Next Step

After completing this task, proceed to **Task 5.2: GUI Functionality Testing**

View document: `部署/任务跟踪-阶段5-联调测试-部署任务5.2-GUI功能测试.md`
