# Phase 5 - Task 5.4: Script Integration Testing - Detailed Deployment Document

**Task ID:** 5.4  
**Task Name:** Script Integration Testing  
**Priority:** P1 (High)  
**Estimated Hours:** 2 hours  
**Status:** Pending  
**Prerequisites:** Task 5.3 completed

---

## I. Task Objectives

Test the unified script system to ensure all scripts work together correctly.

## II. Test Scenarios

### 2.1 Test Coverage

| Script | Test Case | Expected Result |
|--------|-----------|---------------|
| yl-ar-dgn.sh | Help command | Shows help text |
| yl-ar-dgn.sh | Status command | Shows system status |
| yl-ar-dgn.sh | Deploy command | Deploys components |
| yl-ar-dgn.sh | Health check | Returns health status |
| yl-ar-dgn.sh | Cleanup command | Cleans resources |
| Config loader | Load config | Returns configuration |
| Logger | Log message | Writes to log file |
| Error handler | Handle error | Returns error info |

## III. Deployment Content

### 3.1 Script Integration Test

#### File: test/integration/test_scripts_integration.py

```python
#!/usr/bin/env python3
"""
Script Integration Tests
"""

import unittest
import subprocess
import tempfile
import os
from pathlib import Path


class TestEntryPoint(unittest.TestCase):
    """
    Test unified entry point
    """

    def setUp(self):
        self.project_root = Path(__file__).parent.parent.parent
        self.entry_point = self.project_root / 'scripts' / 'yl-ar-dgn.sh'

    def test_entry_point_exists(self):
        """Test entry point exists"""
        self.assertTrue(self.entry_point.exists())

    def test_entry_point_executable(self):
        """Test entry point is executable"""
        self.assertTrue(self.entry_point.stat().st_mode & 0o111)

    def test_help_command(self):
        """Test help command"""
        result = subprocess.run(
            [str(self.entry_point), 'help'],
            cwd=self.project_root,
            capture_output=True,
            text=True
        )
        self.assertEqual(result.returncode, 0)
        self.assertIn('YL-AR-DGN', result.stdout)

    def test_status_command(self):
        """Test status command"""
        result = subprocess.run(
            [str(self.entry_point), 'status'],
            cwd=self.project_root,
            capture_output=True,
            text=True
        )
        self.assertEqual(result.returncode, 0)
        self.assertIn('System Status', result.stdout)


class TestConfigLoader(unittest.TestCase):
    """
    Test configuration loader
    """

    def test_load_config(self):
        """Test loading configuration"""
        from scripts.lib.config_loader import get_config, get

        config = get_config()
        self.assertIsNotNone(config)

        project_name = get('project.name')
        self.assertIsNotNone(project_name)

    def test_get_component_config(self):
        """Test getting component configuration"""
        from scripts.lib.config_loader import get_component

        yl_monitor = get_component('yl_monitor')
        self.assertIn('port', yl_monitor)

    def test_environment_override(self):
        """Test environment variable override"""
        import os
        from scripts.lib.config_loader import get_config

        # Set environment variable
        os.environ['YL_LOG_LEVEL'] = 'DEBUG'

        # Reload config
        config = get_config()
        config.reload()

        log_level = get('scripts.log_level')
        # Should be DEBUG if override worked
        # Note: This depends on actual implementation


class TestLogger(unittest.TestCase):
    """
    Test logging system
    """

    def test_create_logger(self):
        """Test creating logger"""
        from scripts.lib.logger import get_logger

        with tempfile.TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            logger = get_logger('test_integration')
            self.assertIsNotNone(logger)

    def test_log_levels(self):
        """Test different log levels"""
        from scripts.lib.logger import get_logger

        logger = get_logger('test_levels')
        # Should not raise
        logger.debug('Debug')
        logger.info('Info')
        logger.warning('Warning')
        logger.error('Error')


class TestErrorHandler(unittest.TestCase):
    """
    Test error handling
    """

    def test_error_creation(self):
        """Test error creation"""
        from scripts.lib.error_handler import ScriptError, ErrorCode

        error = ScriptError('Test error', ErrorCode.GENERAL_ERROR)
        self.assertEqual(error.message, 'Test error')

    def test_error_handling(self):
        """Test error handling"""
        from scripts.lib.error_handler import ErrorHandler, ScriptError, ErrorCode

        handler = ErrorHandler()
        error = ScriptError('Test', ErrorCode.VALIDATION_ERROR)
        result = handler.handle(error, 'test')
        self.assertTrue(result['error'])


class TestShellLibraries(unittest.TestCase):
    """
    Test shell library functions
    """

    def test_config_sh(self):
        """Test config.sh can be sourced"""
        config_sh = Path(__file__).parent.parent.parent / 'scripts' / 'lib' / 'config.sh'
        self.assertTrue(config_sh.exists())

        # Try to source it
        result = subprocess.run(
            ['bash', '-c', f'source {config_sh} && echo "OK"'],
            capture_output=True,
            text=True
        )
        self.assertEqual(result.returncode, 0)

    def test_logging_sh(self):
        """Test logging.sh can be sourced"""
        logging_sh = Path(__file__).parent.parent.parent / 'scripts' / 'lib' / 'logging.sh'
        self.assertTrue(logging_sh.exists())

        result = subprocess.run(
            ['bash', '-c', f'source {logging_sh} && yl_info "Test"'],
            capture_output=True,
            text=True
        )
        self.assertEqual(result.returncode, 0)


def run_script_tests():
    """Run all script integration tests"""
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()

    suite.addTests(loader.loadTestsFromTestCase(TestEntryPoint))
    suite.addTests(loader.loadTestsFromTestCase(TestConfigLoader))
    suite.addTests(loader.loadTestsFromTestCase(TestLogger))
    suite.addTests(loader.loadTestsFromTestCase(TestErrorHandler))
    suite.addTests(loader.loadTestsFromTestCase(TestShellLibraries))

    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    return result.wasSuccessful()


if __name__ == '__main__':
    success = run_script_tests()
    exit(0 if success else 1)
```

### 3.2 Script Test Runner

#### File: test/integration/run_script_tests.sh

```bash
#!/bin/bash
# Run Script Integration Tests

set -e

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
LOG_FILE="$PROJECT_ROOT/logs/script_tests_$(date +%Y%m%d_%H%M%S).log"

mkdir -p "$(dirname "$LOG_FILE")"

echo "========================================"
echo "Script Integration Tests"
echo "Started: $(date)"
echo "========================================"

# Test entry point commands
echo ""
echo "Testing entry point commands..."

test_command() {
    local cmd=$1
    local expected=$2
    
    echo "  Testing: $cmd"
    if $cmd > /dev/null 2>&1; then
        echo "    ✓ PASS"
        return 0
    else
        echo "    ✗ FAIL (expected: $expected)"
        return 1
    fi
}

# Test help
test_command "$PROJECT_ROOT/scripts/yl-ar-dgn.sh help" "show help"

# Test status
test_command "$PROJECT_ROOT/scripts/yl-ar-dgn.sh status" "show status"

# Test Python libraries
echo ""
echo "Testing Python libraries..."

cd "$PROJECT_ROOT"

if python3 test/integration/test_scripts_integration.py 2>&1 | tee -a "$LOG_FILE"; then
    echo ""
    echo "✓ Script integration tests passed"
    TEST_RESULT=0
else
    echo ""
    echo "✗ Some script tests failed"
    TEST_RESULT=1
fi

# Summary
echo ""
echo "========================================"
echo "Script Test Summary"
echo "========================================"
echo "Log file: $LOG_FILE"

exit $TEST_RESULT
```

## IV. Deployment Steps

```bash
# 1. Create script integration test
# Edit test/integration/test_scripts_integration.py

# 2. Create test runner
# Edit test/integration/run_script_tests.sh

# 3. Make executable
chmod +x test/integration/run_script_tests.sh

# 4. Run tests
./test/integration/run_script_tests.sh
```

## V. Verification Checklist

- [ ] Entry point tests pass
- [ ] Config loader tests pass
- [ ] Logger tests pass
- [ ] Error handler tests pass
- [ ] Shell library tests pass

## VI. Next Step

After completing this task, proceed to **Task 5.5: Rule Engine Testing**

View document: `部署/任务跟踪-阶段5-联调测试-部署任务5.5-规则引擎测试.md`
