# Phase 3 - Task 3.3: Improve L3 Constraint Layer - Detailed Deployment Document

**Task ID:** 3.3  
**Task Name:** Improve L3 Constraint Layer  
**Priority:** P1 (High)  
**Estimated Hours:** 2 hours  
**Status:** Pending  
**Prerequisites:** Task 3.2 completed

---

## I. Task Objectives

Improve the L3 Constraint layer rules to define system limitations, boundaries, and operational constraints.

## II. Deployment Content

### 2.1 Files to Create/Modify

| No. | File Path | Operation | Description |
|-----|-----------|-----------|-------------|
| 1 | `rules/L3-constraints.json` | Modify | Improve constraint rules |
| 2 | `rules/constraint_checker.py` | New | Constraint checker |

### 2.2 Detailed Code Implementation

#### File 1: rules/L3-constraints.json

```json
{
  "layer": "L3",
  "name": "constraints",
  "description": "Constraint layer - defines system limitations, boundaries, and operational constraints",
  "version": "1.0.0",
  "last_updated": "2026-02-09",
  "technical_constraints": {
    "platform": {
      "supported_os": ["Linux (Ubuntu 20.04+)", "Windows 10/11", "macOS 12+"],
      "architecture": ["x86_64", "arm64"],
      "python_version": {
        "minimum": "3.8.0",
        "recommended": "3.10+",
        "constraint": ">=3.8"
      }
    },
    "hardware": {
      "minimum": {
        "cpu": "2 cores",
        "memory": "4GB RAM",
        "storage": "5GB free space",
        "network": "100Mbps LAN"
      },
      "recommended": {
        "cpu": "4+ cores (Intel i5/AMD Ryzen 5 or better)",
        "memory": "8GB+ RAM",
        "storage": "20GB+ SSD",
        "gpu": "NVIDIA GTX 1060 or better with 6GB+ VRAM",
        "network": "1Gbps LAN"
      },
      "maximum": {
        "memory_per_process": "4GB",
        "concurrent_video_streams": 2,
        "max_file_upload_size": "100MB"
      }
    },
    "software": {
      "required_libraries": [
        "PyQt5 >= 5.15",
        "OpenCV >= 4.5",
        "NumPy >= 1.20",
        "Flask >= 2.0",
        "FastAPI >= 0.85"
      ],
      "optional_components": [
        "CUDA Toolkit 11.0+ (for GPU acceleration)",
        "TensorRT (for optimized inference)",
        "OBS Studio (for virtual camera)"
      ],
      "incompatible_software": [
        "Python < 3.8",
        "PyQt4 (deprecated)",
        "OpenCV < 4.0"
      ]
    }
  },
  "performance_constraints": {
    "response_time": {
      "api_calls": {
        "target": "< 200ms",
        "maximum": "< 500ms",
        "measurement": "95th percentile"
      },
      "gui_interactions": {
        "target": "< 50ms",
        "maximum": "< 100ms"
      },
      "video_frame_processing": {
        "target": "< 40ms (25+ FPS)",
        "minimum": "< 66ms (15 FPS)"
      }
    },
    "throughput": {
      "api_requests_per_second": 100,
      "concurrent_users": 10,
      "video_streams": 2
    },
    "resource_usage": {
      "cpu_normal": "< 50%",
      "cpu_peak": "< 80%",
      "memory_normal": "< 2GB",
      "memory_peak": "< 4GB",
      "disk_io": "< 100MB/s"
    }
  },
  "security_constraints": {
    "authentication": {
      "method": "Token-based (JWT)",
      "token_expiry": "24 hours",
      "refresh_token_expiry": "7 days",
      "password_policy": {
        "min_length": 8,
        "require_uppercase": true,
        "require_lowercase": true,
        "require_numbers": true,
        "require_special": true
      }
    },
    "authorization": {
      "model": "Role-Based Access Control (RBAC)",
      "roles": ["admin", "operator", "viewer"],
      "default_role": "viewer"
    },
    "data_protection": {
      "encryption_at_rest": "AES-256",
      "encryption_in_transit": "TLS 1.2+",
      "sensitive_data_masking": true,
      "audit_logging": true
    },
    "network_security": {
      "allowed_ports": [5500, 5501, 5502],
      "firewall_rules": "Deny all, allow specific",
      "rate_limiting": "100 requests per minute per IP"
    }
  },
  "operational_constraints": {
    "deployment": {
      "allowed_hours": "02:00-06:00 (maintenance window)",
      "rollback_time": "< 30 minutes",
      "zero_downtime": false,
      "backup_required": true
    },
    "monitoring": {
      "health_check_interval": "30 seconds",
      "metrics_retention": "30 days",
      "log_retention": "90 days",
      "alert_escalation": "5 minutes"
    },
    "maintenance": {
      "scheduled_maintenance": "Monthly, first Sunday 02:00-06:00",
      "emergency_maintenance": "As needed with 1 hour notice",
      "patch_application": "Within 7 days of release"
    }
  },
  "business_constraints": {
    "compliance": {
      "gdpr": "User data must be deletable within 30 days",
      "copyright": "AI models must respect copyright",
      "export_control": "No export to restricted countries"
    },
    "licensing": {
      "open_source_components": "Must comply with respective licenses",
      "commercial_components": "Valid license required",
      "proprietary_code": "Internal use only"
    }
  }
}
```

#### File 2: rules/constraint_checker.py

```python
#!/usr/bin/env python3
"""
Constraint Checker
Validates system against defined constraints
"""

import json
import psutil
import logging
from pathlib import Path
from typing import Dict, List, Tuple, Optional

logger = logging.getLogger('ConstraintChecker')


class ConstraintChecker:
    """
    Constraint Checker
    """

    def __init__(self):
        self.constraints = {}
        self.load_constraints()

    def load_constraints(self):
        """Load L3 constraints"""
        constraints_file = Path(__file__).parent / 'L3-constraints.json'
        if constraints_file.exists():
            with open(constraints_file) as f:
                data = json.load(f)
                self.constraints = data.get('technical_constraints', {})

    def check_hardware(self) -> Dict:
        """Check hardware against constraints"""
        results = {
            'passed': True,
            'checks': []
        }

        # CPU
        cpu_count = psutil.cpu_count()
        results['checks'].append({
            'item': 'CPU cores',
            'value': cpu_count,
            'required': 2,
            'passed': cpu_count >= 2
        })

        # Memory
        memory = psutil.virtual_memory()
        memory_gb = memory.total / (1024**3)
        results['checks'].append({
            'item': 'Memory',
            'value': f"{memory_gb:.1f}GB",
            'required': '4GB',
            'passed': memory_gb >= 4
        })

        # Disk
        disk = psutil.disk_usage('/')
        free_gb = disk.free / (1024**3)
        results['checks'].append({
            'item': 'Free disk space',
            'value': f"{free_gb:.1f}GB",
            'required': '5GB',
            'passed': free_gb >= 5
        })

        results['passed'] = all(c['passed'] for c in results['checks'])
        return results

    def check_performance(self) -> Dict:
        """Check current performance"""
        results = {
            'cpu_percent': psutil.cpu_percent(interval=1),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_io': psutil.disk_io_counters().read_bytes / 1024 / 1024 if psutil.disk_io_counters() else 0
        }

        # Check against constraints
        constraints = self.constraints.get('performance_constraints', {})
        resource = constraints.get('resource_usage', {})

        results['within_limits'] = (
            results['cpu_percent'] < resource.get('cpu_peak', 80) and
            results['memory_percent'] < 90  # Using percent as proxy
        )

        return results

    def generate_report(self) -> str:
        """Generate constraint check report"""
        hardware = self.check_hardware()
        performance = self.check_performance()

        report = []
        report.append("=" * 60)
        report.append("Constraint Check Report")
        report.append("=" * 60)

        report.append("\nHardware Constraints:")
        for check in hardware['checks']:
            status = "✓" if check['passed'] else "✗"
            report.append(f"  {status} {check['item']}: {check['value']} (required: {check['required']})")

        report.append(f"\nOverall: {'PASS' if hardware['passed'] else 'FAIL'}")

        return '\n'.join(report)


def main():
    """Main function"""
    checker = ConstraintChecker()
    print(checker.generate_report())


if __name__ == '__main__':
    main()
```

## III. Deployment Steps

```bash
# 1. Create L3 constraints file
# Edit rules/L3-constraints.json

# 2. Create constraint checker
# Edit rules/constraint_checker.py

# 3. Validate JSON
python3 -c "import json; json.load(open('rules/L3-constraints.json'))"

# 4. Test constraint checker
python3 rules/constraint_checker.py
```

## IV. Verification Checklist

- [ ] L3 constraints file created
- [ ] Technical constraints defined
- [ ] Performance constraints set
- [ ] Security constraints specified
- [ ] Operational constraints listed
- [ ] Constraint checker works

## V. Next Step

After completing this task, proceed to **Task 3.4: Improve L4 Decision Layer**

View document: `部署/任务跟踪-阶段3-规则架构部署-部署任务3.4-完善L4决策层.md`
