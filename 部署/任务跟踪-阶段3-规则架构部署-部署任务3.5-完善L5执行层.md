# Phase 3 - Task 3.5: Improve L5 Execution Layer - Detailed Deployment Document

**Task ID:** 3.5  
**Task Name:** Improve L5 Execution Layer  
**Priority:** P1 (High)  
**Estimated Hours:** 2 hours  
**Status:** Pending  
**Prerequisites:** Task 3.4 completed

---

## I. Task Objectives

Improve the L5 Execution layer rules to define specific operational steps, procedures, and checklists.

## II. Deployment Content

### 2.1 Files to Create/Modify

| No. | File Path | Operation | Description |
|-----|-----------|-----------|-------------|
| 1 | `rules/L5-execution.json` | Modify | Improve execution rules |
| 2 | `rules/procedure_runner.py` | New | Procedure runner |

### 2.2 Detailed Code Implementation

#### File 1: rules/L5-execution.json

```json
{
  "layer": "L5",
  "name": "execution",
  "description": "Execution layer - defines specific operational steps and procedures",
  "version": "1.0.0",
  "last_updated": "2026-02-09",
  "procedures": [
    {
      "id": "E1",
      "name": "System Startup",
      "description": "Complete system startup procedure",
      "preconditions": [
        "Environment check passed",
        "Dependencies installed",
        "Configuration validated"
      ],
      "steps": [
        {
          "step": 1,
          "name": "Environment Verification",
          "command": "python3 check_env.py",
          "timeout": 30,
          "retry": 1,
          "on_failure": "abort"
        },
        {
          "step": 2,
          "name": "Start YL-monitor",
          "command": "cd YL-monitor && ./start.sh",
          "timeout": 60,
          "retry": 2,
          "on_failure": "retry_then_abort",
          "verify": "curl http://localhost:5500/api/health"
        },
        {
          "step": 3,
          "name": "Start AR-backend",
          "command": "cd AR-backend && ./start.sh",
          "timeout": 60,
          "retry": 2,
          "on_failure": "retry_then_abort",
          "verify": "curl http://localhost:5501/health",
          "delay_after": 5
        },
        {
          "step": 4,
          "name": "Start User GUI",
          "command": "cd user && ./start.sh",
          "timeout": 60,
          "retry": 2,
          "on_failure": "retry_then_abort",
          "verify": "curl http://localhost:5502/health",
          "delay_after": 5
        },
        {
          "step": 5,
          "name": "Verify All Services",
          "command": "python3 verify_services.py",
          "timeout": 30,
          "retry": 1,
          "on_failure": "alert_and_continue"
        }
      ],
      "postconditions": [
        "All services report healthy status",
        "Monitoring dashboard accessible",
        "No critical errors in logs"
      ],
      "estimated_duration": "3 minutes",
      "rollback_procedure": "E2"
    },
    {
      "id": "E2",
      "name": "System Shutdown",
      "description": "Graceful system shutdown procedure",
      "preconditions": [
        "User notified (if production)",
        "Data saved",
        "Backup completed (if needed)"
      ],
      "steps": [
        {
          "step": 1,
          "name": "Stop User GUI",
          "command": "pkill -f 'user/main.py' || true",
          "timeout": 30,
          "graceful": true
        },
        {
          "step": 2,
          "name": "Stop AR-backend",
          "command": "pkill -f 'AR-backend/monitor_server.py' || true",
          "timeout": 30,
          "graceful": true
        },
        {
          "step": 3,
          "name": "Stop YL-monitor",
          "command": "pkill -f 'YL-monitor/app/main.py' || true",
          "timeout": 30,
          "graceful": true
        },
        {
          "step": 4,
          "name": "Verify Shutdown",
          "command": "python3 verify_shutdown.py",
          "timeout": 30
        }
      ],
      "postconditions": [
        "No processes running on ports 5500-5502",
        "Resources released"
      ]
    },
    {
      "id": "E3",
      "name": "Backup Procedure",
      "description": "System backup procedure",
      "preconditions": [
        "Sufficient disk space",
        "System stable"
      ],
      "steps": [
        {
          "step": 1,
          "name": "Create Backup Directory",
          "command": "mkdir -p backups/$(date +%Y%m%d_%H%M%S)",
          "timeout": 10
        },
        {
          "step": 2,
          "name": "Backup Configuration",
          "command": "tar czf backups/config_$(date +%Y%m%d).tar.gz config/",
          "timeout": 60
        },
        {
          "step": 3,
          "name": "Backup Data",
          "command": "tar czf backups/data_$(date +%Y%m%d).tar.gz data/",
          "timeout": 120
        },
        {
          "step": 4,
          "name": "Verify Backup",
          "command": "ls -lh backups/*.tar.gz",
          "timeout": 10
        }
      ]
    }
  ],
  "checklists": {
    "pre_deployment": [
      {"item": "Environment check passed", "mandatory": true},
      {"item": "Dependencies installed", "mandatory": true},
      {"item": "Configuration validated", "mandatory": true},
      {"item": "Backup created", "mandatory": true},
      {"item": "Rollback plan prepared", "mandatory": true},
      {"item": "Team notified", "mandatory": false}
    ],
    "post_deployment": [
      {"item": "Services started", "mandatory": true},
      {"item": "Health check passed", "mandatory": true},
      {"item": "Monitoring active", "mandatory": true},
      {"item": "Logs normal", "mandatory": true},
      {"item": "Users can access", "mandatory": true}
    ],
    "daily_operations": [
      {"item": "Check service status"},
      {"item": "Review logs for errors"},
      {"item": "Check resource usage"},
      {"item": "Verify backups"}
    ]
  }
}
```

#### File 2: rules/procedure_runner.py

```python
#!/usr/bin/env python3
"""
Procedure Runner
Executes L5 procedures
"""

import json
import subprocess
import logging
import time
from pathlib import Path
from typing import Dict, List, Optional

logger = logging.getLogger('ProcedureRunner')


class ProcedureRunner:
    """
    Procedure Runner
    """

    def __init__(self):
        self.procedures = {}
        self.load_procedures()

    def load_procedures(self):
        """Load L5 procedures"""
        procedures_file = Path(__file__).parent / 'L5-execution.json'
        if procedures_file.exists():
            with open(procedures_file) as f:
                data = json.load(f)
                for proc in data.get('procedures', []):
                    self.procedures[proc['id']] = proc

    def run_procedure(self, procedure_id: str, dry_run: bool = False) -> Dict:
        """
        Run a procedure
        """
        procedure = self.procedures.get(procedure_id)
        if not procedure:
            return {'success': False, 'error': 'Procedure not found'}

        logger.info(f"Running procedure: {procedure['name']}")

        results = {
            'procedure_id': procedure_id,
            'steps_completed': [],
            'steps_failed': [],
            'success': True
        }

        for step in procedure.get('steps', []):
            step_result = self._execute_step(step, dry_run)

            if step_result['success']:
                results['steps_completed'].append(step)
            else:
                results['steps_failed'].append(step)
                if step.get('on_failure') == 'abort':
                    results['success'] = False
                    break

            # Delay after step if specified
            delay = step.get('delay_after', 0)
            if delay > 0:
                time.sleep(delay)

        return results

    def _execute_step(self, step: Dict, dry_run: bool) -> Dict:
        """
        Execute a single step
        """
        name = step.get('name', 'Unknown')
        command = step.get('command', '')

        logger.info(f"Executing step: {name}")

        if dry_run:
            logger.info(f"  [DRY RUN] Would execute: {command}")
            return {'success': True, 'dry_run': True}

        try:
            timeout = step.get('timeout', 60)
            result = subprocess.run(
                command,
                shell=True,
                timeout=timeout,
                capture_output=True,
                text=True
            )

            success = result.returncode == 0

            if success:
                logger.info(f"  ✓ Step completed: {name}")
            else:
                logger.error(f"  ✗ Step failed: {name}")
                logger.error(f"    Error: {result.stderr}")

            return {
                'success': success,
                'stdout': result.stdout,
                'stderr': result.stderr
            }

        except subprocess.TimeoutExpired:
            logger.error(f"  ✗ Step timeout: {name}")
            return {'success': False, 'error': 'timeout'}
        except Exception as e:
            logger.error(f"  ✗ Step error: {name} - {e}")
            return {'success': False, 'error': str(e)}

    def run_checklist(self, checklist_name: str) -> Dict:
        """
        Run a checklist
        """
        checklists_file = Path(__file__).parent / 'L5-execution.json'
        with open(checklists_file) as f:
            data = json.load(f)

        checklist = data.get('checklists', {}).get(checklist_name, [])

        results = {
            'checklist': checklist_name,
            'items': [],
            'all_passed': True
        }

        for item in checklist:
            # Simulate checking
            checked = True  # In real implementation, actual check
            results['items'].append({
                'item': item.get('item'),
                'checked': checked,
                'mandatory': item.get('mandatory', False)
            })
            if item.get('mandatory') and not checked:
                results['all_passed'] = False

        return results


def main():
    """Main function"""
    runner = ProcedureRunner()

    # Test
    print("Available procedures:")
    for proc_id, proc in runner.procedures.items():
        print(f"  {proc_id}: {proc['name']}")

    # Run with dry-run
    result = runner.run_procedure('E1', dry_run=True)
    print(f"\nProcedure result: {result}")


if __name__ == '__main__':
    main()
```

## III. Deployment Steps

```bash
# 1. Create L5 execution file
# Edit rules/L5-execution.json

# 2. Create procedure runner
# Edit rules/procedure_runner.py

# 3. Validate JSON
python3 -c "import json; json.load(open('rules/L5-execution.json'))"

# 4. Test procedure runner
python3 rules/procedure_runner.py
```

## IV. Verification Checklist

- [ ] L5 execution file created
- [ ] Procedures defined
- [ ] Steps detailed
- [ ] Checklists created
- [ ] Procedure runner works

## V. Next Step

After completing this task, proceed to **Task 3.6: Improve Rule Engine**

View document: `部署/任务跟踪-阶段3-规则架构部署-部署任务3.6-完善规则引擎.md`
