#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Dependency Vulnerability Check
依赖漏洞检测脚本（轻量、可在本仓库直接落地）

目标:
- 读取 requirements.txt
- 获取本机已安装版本（或从 requirements 的 pin 版本推断）
- 基于内置的“已知漏洞小型库”做快速比对

使用:
  python3 scripts/security/vulnerability_check.py \
    --requirements AR-backend/requirements/requirements.txt \
    --output text

退出码:
  - 2: 存在 critical
  - 1: 存在 high（且无 critical）
  - 0: 其余情况（含仅 medium/low/info 或未发现）
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from dataclasses import asdict, dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

try:
    from importlib import metadata  # Python 3.8+
except Exception:  # pragma: no cover
    metadata = None  # type: ignore[assignment]


REPO_ROOT = Path(__file__).resolve().parents[2]
DEFAULT_REQUIREMENTS = REPO_ROOT / "AR-backend" / "requirements" / "requirements.txt"


@dataclass(frozen=True)
class Vulnerability:
    package: str
    current_version: str
    affected: str
    severity: str
    cve: str
    description: str
    fixed_in: str = ""


KNOWN_VULNERABILITIES: Dict[str, List[Dict[str, str]]] = {
    # Web / common
    "flask": [
        {
            "cve": "CVE-2018-1000656",
            "severity": "high",
            "affected": "<0.12.3",
            "fixed_in": "0.12.3",
            "description": "Flask 模板注入/目录穿越相关漏洞（历史版本）",
        }
    ],
    "requests": [
        {
            "cve": "CVE-2018-18074",
            "severity": "medium",
            "affected": "<2.20.0",
            "fixed_in": "2.20.0",
            "description": "Requests 头部注入相关漏洞（历史版本）",
        }
    ],
    "jinja2": [
        {
            "cve": "CVE-2023-30608",
            "severity": "medium",
            "affected": "<3.1.3",
            "fixed_in": "3.1.3",
            "description": "Jinja2 沙箱绕过漏洞",
        }
    ],
    "pyyaml": [
        {
            "cve": "CVE-2023-2251",
            "severity": "high",
            "affected": "<6.0.1",
            "fixed_in": "6.0.1",
            "description": "PyYAML 代码执行漏洞",
        }
    ],
    "urllib3": [
        {
            "cve": "CVE-2023-45803",
            "severity": "medium",
            "affected": "<1.26.18",
            "fixed_in": "1.26.18",
            "description": "urllib3 代理配置相关漏洞",
        }
    ],
    "cryptography": [
        {
            "cve": "CVE-2023-49083",
            "severity": "high",
            "affected": "<41.0.4",
            "fixed_in": "41.0.4",
            "description": "Cryptography 拒绝服务漏洞（历史版本）",
        }
    ],
    "aiohttp": [
        {
            "cve": "CVE-2023-47627",
            "severity": "high",
            "affected": "<3.9.1",
            "fixed_in": "3.9.1",
            "description": "AioHTTP 开放重定向漏洞（历史版本）",
        }
    ],
    # CV / scientific
    "numpy": [
        {
            "cve": "CVE-2019-6446",
            "severity": "high",
            "affected": "<1.16.6",
            "fixed_in": "1.16.6",
            "description": "NumPy 缓冲区溢出漏洞（历史版本）",
        }
    ],
    "opencv-python": [
        {
            "cve": "CVE-2021-34150",
            "severity": "medium",
            "affected": "<4.5.5.64",
            "fixed_in": "4.5.5.64",
            "description": "OpenCV 缓冲区溢出漏洞（历史版本）",
        }
    ],
}


def _normalize_name(name: str) -> str:
    return name.strip().lower().replace("_", "-")


def _extract_version_tuple(version: str) -> Tuple[int, ...]:
    # 仅取数字部分，足够覆盖大多数 x.y.z 场景
    parts = [int(p) for p in re.findall(r"\d+", version)]
    return tuple(parts or [0])


def _compare_versions(a: str, b: str) -> int:
    ta = _extract_version_tuple(a)
    tb = _extract_version_tuple(b)
    max_len = max(len(ta), len(tb))
    ta = ta + (0,) * (max_len - len(ta))
    tb = tb + (0,) * (max_len - len(tb))
    return (ta > tb) - (ta < tb)


def _satisfies(version: str, spec: str) -> bool:
    """
    支持:
      - <, <=, >, >=, ==
      - 多条件用逗号分隔：">=1.0,<2.0"
    """
    spec = spec.strip()
    if not spec:
        return False

    for part in spec.split(","):
        part = part.strip()
        if not part:
            continue

        match = re.match(r"^(<=|>=|<|>|==)\s*([0-9A-Za-z._+-]+)$", part)
        if not match:
            return False

        op, target = match.group(1), match.group(2)
        cmp_result = _compare_versions(version, target)

        ok = {
            "<": cmp_result < 0,
            "<=": cmp_result <= 0,
            ">": cmp_result > 0,
            ">=": cmp_result >= 0,
            "==": cmp_result == 0,
        }[op]
        if not ok:
            return False

    return True


def _guess_pinned_version(spec: str) -> Optional[str]:
    # 从 "==1.2.3" 推断 pinned 版本；其余情况返回 None
    match = re.search(r"==\s*([0-9A-Za-z._+-]+)", spec)
    return match.group(1) if match else None


def _read_requirements(path: Path, seen: Optional[set[Path]] = None) -> Dict[str, str]:
    seen = seen or set()
    path = path.resolve()
    if path in seen:
        return {}
    seen.add(path)

    if not path.exists():
        raise FileNotFoundError(str(path))

    requirements: Dict[str, str] = {}

    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue

        # 兼容 "-r other.txt" / "--requirement other.txt"
        if line.startswith("-r ") or line.startswith("--requirement "):
            include_path = line.split(maxsplit=1)[1].strip()
            nested = (path.parent / include_path).resolve()
            requirements.update(_read_requirements(nested, seen=seen))
            continue

        # 去掉 marker: "pkg>=1; python_version<'3.12'"
        if ";" in line:
            line = line.split(";", 1)[0].strip()

        # 跳过 URL / editable / options
        if line.startswith(("-e ", "--", "git+", "http://", "https://")):
            continue

        name_part = re.split(r"[<>=!~]", line, 1)[0].strip()
        name_part = name_part.split("[", 1)[0].strip()
        if not name_part:
            continue

        package = _normalize_name(name_part)
        spec = line[len(name_part) :].strip()
        requirements[package] = spec

    return requirements


def _get_installed_version(package: str) -> Optional[str]:
    if metadata is None:
        return None
    try:
        return metadata.version(package)
    except Exception:
        return None


def check_vulnerabilities(requirements: Dict[str, str]) -> Tuple[List[Vulnerability], List[str]]:
    found: List[Vulnerability] = []
    unknown: List[str] = []

    for package, spec in sorted(requirements.items()):
        package_key = _normalize_name(package)
        rules = KNOWN_VULNERABILITIES.get(package_key)
        if not rules:
            continue

        installed_version = _get_installed_version(package_key)
        pinned_version = _guess_pinned_version(spec)
        current_version = installed_version or pinned_version

        if not current_version:
            unknown.append(package_key)
            continue

        for rule in rules:
            affected = rule["affected"]
            if _satisfies(current_version, affected):
                found.append(
                    Vulnerability(
                        package=package_key,
                        current_version=current_version,
                        affected=affected,
                        severity=rule["severity"],
                        cve=rule["cve"],
                        description=rule["description"],
                        fixed_in=rule.get("fixed_in", ""),
                    )
                )

    return found, unknown


def _summarize(vulns: Iterable[Vulnerability]) -> Dict[str, int]:
    summary = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
    for v in vulns:
        summary[v.severity] = summary.get(v.severity, 0) + 1
    return {k: v for k, v in summary.items() if v}


def _exit_code(summary: Dict[str, int]) -> int:
    if summary.get("critical", 0) > 0:
        return 2
    if summary.get("high", 0) > 0:
        return 1
    return 0


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="依赖漏洞检测工具（轻量版）")
    parser.add_argument(
        "--output",
        "-o",
        choices=["json", "text"],
        default="text",
        help="输出格式 (默认: text)",
    )
    parser.add_argument(
        "--requirements",
        "-r",
        default=str(DEFAULT_REQUIREMENTS),
        help=f"requirements.txt 路径 (默认: {DEFAULT_REQUIREMENTS})",
    )
    args = parser.parse_args(argv)

    requirements_path = Path(args.requirements)
    try:
        requirements = _read_requirements(requirements_path)
    except FileNotFoundError:
        print(f"[ERROR] requirements.txt 不存在: {requirements_path}", file=sys.stderr)
        return 2

    vulns, unknown = check_vulnerabilities(requirements)
    summary = _summarize(vulns)

    report = {
        "timestamp": datetime.now().isoformat(),
        "requirements": str(requirements_path),
        "packages_in_requirements": len(requirements),
        "unknown_versions": unknown,
        "vulnerabilities": [asdict(v) for v in vulns],
        "severity_summary": summary,
    }

    if args.output == "json":
        print(json.dumps(report, ensure_ascii=False, indent=2))
    else:
        print("=" * 60)
        print("依赖漏洞检测报告（轻量版）")
        print("=" * 60)
        print(f"requirements: {requirements_path}")
        print(f"发现漏洞: {len(vulns)} 个")
        if summary:
            print("严重性统计:", " ".join([f"{k}:{v}" for k, v in summary.items()]))
        if unknown:
            print(f"⚠️  未能获取版本的包: {', '.join(unknown)}")
        if vulns:
            print("-" * 60)
            for v in vulns:
                fixed = f"（fixed_in: {v.fixed_in}）" if v.fixed_in else ""
                print(f"[{v.severity.upper()}] {v.package} {v.current_version} 受影响 {v.affected} - {v.cve}{fixed}")
                print(f"  {v.description}")
        print("=" * 60)

    return _exit_code(summary)


if __name__ == "__main__":
    raise SystemExit(main())

